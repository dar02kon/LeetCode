# 算法思想集训3

## 动态规划

### 算法思想

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：**适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）**。

动态规划的设计都有着一定的模式，一般要经历以下几个步骤：

* 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
* 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
* 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
* 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

### 分割整数

####  整数拆分

##### 题目描述

[原题链接](https://leetcode.cn/problems/integer-break/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/IntegerBreak.java)

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

 

**提示:**

- `2 <= n <= 58`

##### 题解

整数 i 拆分的最大乘积与 [2,i-1] 的最大乘积息息相关。对于具体数字10，可以将其初步拆分成1 与 9，2 与 8，……，5 与 5，并且对于 9，8，7，6，5又需要考虑是否需要继续进行拆分，考虑是否拆分的前提是我们已经知道拆分后的最大乘积与不拆分的最大乘积哪个大，最终需要对初步拆分的结果进行比较取最大值。

设置数组 dp[i] 表示 i 的最大乘积，对于 i 我们可以将其拆分为 j 与 i-j，其中 j 属于[1,i/2]。对 i-j我们需要考虑是否继续拆分，即比较`(j * (i - j))`与` j * dp[i - j]`的值，前者表示不拆分，后者表示拆分后乘积的最大值，取两者的最大值。同时由于 j 的取值并不唯一，也需要进行比较取最大值。

最终的转换方程为`dp[i] = Math.max(dp[i], Math.max((j * (i - j)), j * dp[i - j]));`

```java
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i / 2; j++) {//将i拆分成 j 与 i-j
                // j * (i - j) 表示不对 i-j 进行拆分的乘积，
                // j * dp[i - j] 表示对 i- j进行拆分
                // 取上面结果的最大值与 dp[i] 进行比较，根据 j 的取值，dp[i]会有多种结果，取其中的最大值
                dp[i] = Math.max(dp[i], Math.max((j * (i - j)), j * dp[i - j]));
            }
        }
        return dp[n];
    }
```

#### 完全平方数

##### 题目描述

[原题链接](https://leetcode.cn/problems/perfect-squares/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/PerfectSquares.java)

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

 

**提示：**

- `1 <= n <= 10^4`

##### 题解

设置数组`dp[i]`表示和为 i 的完全平方数的最少数量

对于数字 i，将 i 拆分为` j*j `与` i-j*j`，其中`j*j`是一个完全平方数，对结果的贡献值固定为1，`dp[i-j*j]`表示和为 `i-j*j` 的完全平方数的最少数量，由于 j 的取值不同会带来多种结果，取其中的最小值

```java
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int min = n;
            for (int j = 1; j * j <= i; j++) {// 将 i 拆分为 j*j 与 i-j*j
                // j*j为一个完全平方数，它的贡献值固定为1，
                // i-j*j的贡献值由于j的不同有多种结果，取其最小值
                min = Math.min(min, dp[i - j * j]);
            }
            dp[i] = min + 1;// 1为 j*j 的贡献值
        }
        return dp[n];
    }
```

#### 解码方法

##### 题目描述

[原题链接](https://leetcode.cn/problems/decode-ways/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/DecodeWays.java)

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

 

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**

```
输入：s = "06"
输出：0
解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
```

 

**提示：**

- `1 <= s.length <= 100`
- `s` 只包含数字，并且可能包含前导零。

##### 题解

对于数字 226，可以一步一步进行映射。2的解码总数为1；22的解码总数为 2，即 `[2,2]`与`[22]`；226的解码总数为3，即22的解码总数加上2的解码总数，因为226可以分为`[22,6]`与`[2,26]`

设置数组dp[i]，表示 0 到 i 位组成的字符串有多少种解码结果，初步可以得出 在第 i 位与 i-1 位组成的数字可以映射时`dp[i] = dp[i-1]+dp[i-2]`，不能映射时`dp[i] = dp[i-1]`，可以发现`dp[i]`需要根据`dp[i-1]`以及`dp[i-2]`得出，其实两个变量就可以存储了。但由于0的特殊性，情况可能会有所不同。

```java
    public int numDecodings(String s) {
        if (s.charAt(0) == '0') return 0;
        int pre1 = 1;//前一位
        int pre2 = 1;//前两位
        int dp;
        for (int i = 1; i < s.length(); i++) {
            int num = (s.charAt(i - 1) - '0') * 10 + (s.charAt(i) - '0');//组合数字
            if (s.charAt(i) != '0') {//该位不为0
                if (s.charAt(i - 1) != '0' && num >= 1 && num <= 26) {//组合数字可以映射 形如 122
                    dp = pre1 + pre2;
                } else {//不能映射 形如 206
                    dp = pre2;
                }
            } else {//该位为0
                if (s.charAt(i - 1) != '0' && num >= 1 && num <= 26) {//组合数字可以映射 形如 20
                    dp = pre1;
                } else {//不能映射 形如 60
                    return 0;
                }
            }
            pre1 = pre2;
            pre2 = dp;
        }
        return pre2;
    }
```

### 矩阵路径

#### 不同路径

##### 题目描述

[原题链接](https://leetcode.cn/problems/unique-paths/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/UniquePaths.java)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 10^9`

##### 题解

机器人每次只能向下或者向右移动一步，若设置二维数组`dp[i][j]`表示抵达坐标`(i,j)`一共有多少路径，则不越界的情况下存在递推关系`dp[i][j]=dp[i-1][j]+dp[i][j-1]`，左边界与上边界只有一条路径可达（一直向下或者一直向右）

如果我们从左往右，从上往下进行遍历，只需要一维数组进行记录即可，很多数据在遍历过程中都会失去作用（第一行对于第三行来说就没有作用），`dp[i][j]`只与`dp[i-1][j]`，`dp[i][j-1]`有关，可以映射到一行，则有`dp[j] = dp[j]+dp[j-1]`，`dp[j]`表示上一行对应 j 列的可达路径总数，`dp[j-1]`表示当前行 j-1 列的可达路径总数

```java
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 0; i <m ; i++) {
            for (int j = 1; j <n ; j++) {
                if(i==0){
                    dp[j]=dp[j-1];//一路向右
                } else {
                    dp[j] = dp[j]+dp[j-1];
                }
            }
        }
        return dp[n-1];
    }
```

#### 最小路径和

##### 题目描述

[原题链接](https://leetcode.cn/problems/minimum-path-sum/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/MinimumPathSum.java)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 100`

##### 题解

与不同路径做法相同，只需要一个一维数组进行记录即可，只不过是记录最短路径和

```java
    public int minPathSum(int[][] grid) {
        int[] dp = new int[grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (j == 0) {//一直往下
                    dp[0] = dp[0] + grid[i][0];
                } else if (i == 0) {//一直往右
                    dp[j] = dp[j - 1] + grid[0][j];
                } else {//有两种走法，取路径短的
                    dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
                }
            }
        }
        return dp[grid[0].length - 1];
    }
```

### 斐波那契数列

#### 爬楼梯

##### 题目描述

[原题链接](https://leetcode.cn/problems/climbing-stairs/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/ClimbingStairs.java)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

 

**提示：**

- `1 <= n <= 45`

##### 题解

数组数组dp[i] 表示走到第 i 个 楼梯的方法数目。第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走 到第 i-1 和第 i-2 个楼梯的方法数之和。即`dp[i]=dp[i-1]+dp[i-2]`，由于`dp[i] `只与到达前面的两个台阶方法数有关，所以只需要用两个变量进行存储，动态更新这两个变量

```java
    public int climbStairs(int n) {
        int pre1 = 0, pre2 = 1;
        for (int i = 0; i < n; i++) {
            int num = pre1 + pre2;
            pre1 = pre2;
            pre2 = num;
        }
        return pre2;
    }
```

#### 打家劫舍

##### 题目描述

[原题链接](https://leetcode.cn/problems/house-robber/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/HouseRobber.java)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

##### 题解

定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。由于不能抢劫 邻近住户，因此如果抢劫了第 i 个住户那么只能抢劫 i - 2 和 i - 3 的住户，所以`dp[i]=Math.max(dp[i-2],dp[i-3])+dp[i]`。

可以动态更新三个变量来代替数组存储

```java
    public int rob(int[] nums) {
        int pre1 = 0, pre2 = 0, pre3 = nums[0];
        int max = pre3;
        for (int i = 1; i < nums.length; i++) {
            int num = Math.max(pre1, pre2) + nums[i];
            pre1 = pre2;
            pre2 = pre3;
            pre3 = num;
            max = Math.max(max, pre3);
        }
        return max;
    }
```

#### 打家劫舍 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/house-robber-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/HouseRobberII.java)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：3
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

##### 题解

对于数组nums，起始与末尾元素只会有一个被访问（被偷），可以将数组拆分为`[0,n)`与`[1,n-1)`，n为数组元素个数，即对数组进行划分访问再比较

```java
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        return Math.max(rob(nums, 0, nums.length - 1), rob(nums, 1, nums.length));
    }

    public int rob(int[] nums, int start, int end) {
        int pre1 = 0, pre2 = 0, pre3 = nums[start];
        int max = pre3;
        for (int i = start + 1; i < end; i++) {
            int num = Math.max(pre1, pre2) + nums[i];
            pre1 = pre2;
            pre2 = pre3;
            pre3 = num;
            max = Math.max(max, pre3);
        }
        return max;
    }
```

### 最长递增子序列

#### 最长递增子序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/LongestIncreasingSubsequence.java)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

 

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

##### 题解

定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。 对于一个递增子序列 `{Si1 , Si2 ,...,Sim}`，如果` im < n 并且 Sim < Sn` ，此时 `{Si1 , Si2 ,..., Sim, Sn }` 为一个 递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列 就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 `dp[n] = max{ dp[i]+1 | Si < Sn && i < n} `。 因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 `{Sn } `就构成了递增子序列，因此需要对前面的求解方程做修改，令 dp[n] 最小为 1，

```java
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;//最小为1，自己构成一个子串
            for (int j = 0; j < i; j++) {//选取最长的
                if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            result = Math.max(result, dp[i]);
        }
        return result;
    }
```

可以使用二分查找使得时间复杂度降低为 `O(nlogn )`。定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素，例如对于数组 [4,5,6,3]，有

```
len = 1 : [4], [5], [6], [3] => tails[0] = 3
len = 2 : [4, 5], [5, 6] => tails[1] = 5
len = 3 : [4, 5, 6] => tails[2] = 6
```

对于一个元素 x，如果它大于 tails 数组所有的值，那么把它添加到 tails 后面；如果 tails[i-1] < x <= tails[i]，那么更新 tails[i] = x 。 可以看出 tails 数组保持有序，因此在查找 Si 位于 tails 数组的位置时就可以使用二分查找。

```java
    public int lengthOfLIS2(int[] nums) {
        int[] tail = new int[nums.length];
        int size = 0;//记录最长递增子序列的长度
        for (int num : nums) {
            int index = binarySearch(tail, size, num);
            tail[index] = num;
            if (index == size) size++;//已经新加了一个字符
        }
        return size;
    }
    // 二分搜索，若数组元素均大于目标值，返回0，更新下标为0的元素；
    // 均小于目标值，返回size，新加一个元素
    private int binarySearch(int[] tail, int right, int key) {
        int left = 0;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (tail[mid] == key) return mid;
            if (tail[mid] > key) right = mid;
            else left = mid + 1;
        }
        return left;
    }
```

#### 摆动序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/wiggle-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/WiggleSubsequence.java)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

 

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例 2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例 3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

##### 题解

设置两个状态up与down，up表示最后两个数字递增的最长摆动子串的长度，down表示最后两个数字递减的最长摆动子串的长度。新的down一定在up的基础上产生，新的up一定在down的基础上产生

遍历数组，出现`nums[i+1]>nums[i]`时，如果down的最后一位恰好为i，那很好理解只需要添加nums[i+1]构成新的up，如`[1,2,1,2],i为2的情景`；如果down的最后一位不为i，这里记为j，则 j 到 i 一定是递增序列，如`[4,1,5,6,7,8,9],j为1，i为5`，从下标为2到6的过程都是在down的基础上更新up，down本身其实没变，up的长度也没有改变。所以出现`nums[i+1]>nums[i]`时，`up=down+1`。同理`nums[i+1]<nums[i]`时，`down = up+1`

```java
    public int wiggleMaxLength(int[] nums) {
        int up = 1;//最后两个数字递增，需要一个较小的数字
        int down = 1;//最后两个数字递减，需要一个较大的数字
        for (int i = 0; i <nums.length-1 ; i++) {
            if(nums[i+1]>nums[i]) up = down+1;
            if(nums[i+1]<nums[i]) down = up+1;
        }
        return Math.max(up,down);
    }
```

### 最长公共子系列

对于两个子序列 S1 和 S2，找出它们最长的公共子序列。 

定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 `dp[i][j]` 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：

① 当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再 加上 S1i 这个值，最长公共子序列长度加 1 ，即 `dp[i][j] = dp[i-1][j-1] + 1`。

② 当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列， 与 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，它们的最大者，即 `dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }`。

与最长递增子序列相比，最长公共子序列有以下不同点： 

① 针对的是两个序列，求它们的最长公共子序列。 

② 在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最 长公共子序列中，`dp[i][j] `表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包 含 S1i 和 S2j 。 

③ 由于 2 ，在求最终解时，最长公共子序列中 `dp[N][M]` 就是最终解，而最长递增子序列中 dp[N] 不 是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。

#### 最长公共子序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-common-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/LongestCommonSubsequence.java)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

 

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

 

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

##### 题解

```java
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1))//相等
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else //不相等
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m][n];
    }
```

### 0-1 背包

有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。

定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示体积不超过 j 的情况下，前 i 件物品能达到的 最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况 讨论： 

① 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件 物品的最大价值，`dp[i][j] = dp[i-1][j]`。

 ② 第 i 件物品添加到背包中，`dp[i][j] = dp[i-1][j-w] + v`。 第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。 

综上，0-1 背包的状态转移方程为：`dp[i][j] = max(dp[i-1][j],dp[i-1][j-w] + v)`

> **空间优化**
>
> 在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅由前 i-1 件 物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示`dp[i-1][j]`也可以表示 `dp[i][j]`，换句话说我们只关心 j 能否被表示出来，不需要考虑怎么表示。此时，`dp[j] = max(dp[j],dp[j-w]+v)`
>
> 因为 `dp[j-w]` 表示 `dp[i-1][j-w]`，因此不能先求 `dp[i][j-w] `防止将 `dp[i-1][j-w]`覆盖。也就是说要先计算 `dp[i][j]`再计算 `dp[i][j-w]`，在程序实现时需要按倒序来循环求解。

> **无法使用贪心算法的解释**
>
> 0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这 是因为这种方式可能造成背包空间的浪费，从而无法达到最优。

#### 分割等和子集

##### 题目描述

[原题链接](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/PartitionEqualSubsetSum.java)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

##### 题解

我们先求出整个数组的和 sum（若sum不能被2整除直接返回false），判断数组中的数字能否组成 sum/2

可以看成一个背包大小为 sum/2 的 0-1 背包问题，但是也有不同的地方，这里没有价值属性，并且背包必须被填满。

```java
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {// 数组和
            sum += num;
        }
        if (sum % 2 != 0) {
            return false;
        }
        sum = sum / 2;// 背包大小
        // dp[i][j]表示数字j能否由下标为i以及i之前的数字组成
        boolean[][] dp = new boolean[nums.length][sum+1];
        if (nums[0] <= sum)
            dp[0][nums[0]] = true;// 第一个元素只能表示一个数字
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= sum; j++) {
                // 递推关系
                // 若j<nums[i],说明下标i对应的元素太大，不能参加表示，
                // 只能用前下标为i-1以及之前的元素来表示
                if (j >= nums[i])
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                else
                    dp[i][j] = dp[i - 1][j];
            }
            //找到可以提前结束
            if (dp[i][sum]) {
                return true;
            }
        }
        return dp[nums.length - 1][sum];
    }
```

> **`dp[0][0] = true`**
>
> 修改状态数组初始化的定义：`dp[0][0] = true`。考虑容量为 0 的时候，即` dp[i][0]`。按照本意来说，应该设置为 false ，但是注意到状态转移方程（代码中）：
>
> `dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];`
> 当 j - nums[i] == 0 成立的时候，根据上面分析，就说明单独的 nums[i] 这个数就恰好能够在被分割为单独的一组，其余的数分割成为另外一组。因此，我们把初始化的 `dp[i][0] `设置成为 true 是没有问题的。只要做的好处就是可以使数组在特殊情况下，如存在nums[i] = sum/2，可以提前结束

**空间优化**

```java
    public boolean canPartition2(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum % 2 != 0) {
            return false;
        }
        sum = sum / 2;
        // dp[i]表示数组中的数字能否组成i
        boolean[] dp = new boolean[sum + 1];
        if (nums[0] <= sum)
            dp[nums[0]] = true;
        for (int i = 1; i < nums.length; i++) {
            //从后往前
            for (int j = sum; j >= nums[i]; j--) {
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[sum];
    }
```

#### 单词拆分

##### 题目描述

[原题链接](https://leetcode.cn/problems/word-break/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/WordBreak.java)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

 

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅有小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

##### 题解

设置dp数组，`dp[i]`标识0 到 i组成的字符串能够被表示，`dp[0]`表示空串，所以`dp[0]=true`。

```java
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length()+1];
        dp[0] = true;
        for (int i = 1; i <= s.length() ; i++) {
            for (String word : wordDict) {//遍历字典
                if(word.length()<=i&&s.substring(i-word.length(),i).equals(word)){
                    dp[i] = dp[i]||dp[i-word.length()];//判断前一部分能否被表示
                }
            }
        }
        return dp[s.length()];
    }
```

#### 目标和

##### 题目描述

[原题链接](https://leetcode.cn/problems/target-sum/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/TargetSum.java)

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

 

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

##### 题解

令 P 表示使用正号，N 使用负号，有则有：

```
sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
2 * sum(P) = target + sum(nums)
```

因此只要找到一个子集，令它们都取正号，并且和等于 `(target + sum(nums))/2`，就证明存在解

设置dp数组，`dp[i][j]`表示用前 i 个数字表示 j 有多少种可能

初始条件`dp[0][0]=1`

转换方程为：

```
j<nums[i]:
	dp[i][j] = dp[i−1][j]
j>=nums[i]:
	dp[i][j] = dp[i−1][j]+dp[i−1][j−nums[i]]
```

```java
    public int findTargetSumWays2(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        // 特殊情况
        if (sum < target || -sum > target || (sum + target) % 2 != 0) {
            return 0;
        }
        target = (target + sum) / 2;
        int[][] dp = new int[nums.length+1][target+1];
        dp[0][0] = 1;//初始条件
        for (int i = 1; i <= nums.length; i++) {// 下标从1开始为了方便表示
            int num = nums[i - 1];
            for (int j = 0; j <= target; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= num) {
                    dp[i][j] += dp[i - 1][j - num];
                }
            }
        }
        return dp[nums.length][target];
    }
```

由于 dp 的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 dp 的第一个维度，优化空间。

实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是 `dp[i−1][] `中的元素值，根据上面的转换方程也可以发现`dp[i][j]`与`dp[i−1][j]`以及`dp[i−1][j−nums[i]]`有关，如果使用一维数组`dp[i]`来表示上一行的情况，内层循环正序遍历，会使上一层的值还没有完全使用前就被新的值给覆盖了

```java
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum < target || -sum > target || (sum + target) % 2 != 0) {
            return 0;
        }
        target = (target + sum) / 2;
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int j = target; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[target];
    }
```

#### 一和零

##### 题目描述

[原题链接](https://leetcode.cn/problems/ones-and-zeroes/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/OnesAndZeroes.java)

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

 

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`

##### 题解

定义三维数组 dp，其中 `dp[i][j][k]`表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量。

则转换方程为：

```
j<zero  ∣  k<one
dp[i][j][k] = dp[i-1][j][k];
j≥zero & k≥one
dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-zero][k-one]+1);
```

在尝试添加一个字符串时，需要同时满足`j≥zero & k≥one`，才能保证操作的一致

```java
    public int findMaxForm(String[] strs, int m, int n) {
        int[][][] dp = new int[strs.length+1][m+1][n+1];
        for (int i = 1; i <= strs.length; i++) {
            String str = strs[i - 1];
            int zero = 0, one = 0;
            // 统计 0 和 1 的个数
            for (int k = 0; k < str.length() ; k++) {
                if(str.charAt(k)=='0'){
                    zero++;
                } else {
                    one++;
                }
            }
            for (int j = 0; j <= m ; j++) {
                for (int k = 0; k <= n ; k++) {
                    if(zero<=j&&one<=k){
                       dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-zero][k-one]+1);
                    } else {
                        dp[i][j][k] = dp[i-1][j][k];
                    }
                }
            }
        }
        return dp[strs.length][m][n];
    }
```

同样可以对空间进行优化

```java
    public int findMaxForm2(String[] strs, int m, int n) {
        int[][] dp = new int[m+1][n+1];
        for (int i = 1; i <= strs.length; i++) {
            String str = strs[i - 1];
            int zero = 0, one = 0;
            for (int k = 0; k < str.length() ; k++) {
                if(str.charAt(k)=='0'){
                    zero++;
                } else {
                    one++;
                }
            }
            for (int j = m; j >= zero ; j--) {
                for (int k = n; k >= one ; k--) {

                    dp[j][k] = Math.max(dp[j][k],dp[j-zero][k-one]+1);
                }
            }
        }
        return dp[m][n];
    }
```

#### 零钱兑换

##### 题目描述

[原题链接](https://leetcode.cn/problems/coin-change/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/CoinChange.java)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

 

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

##### 题解

完全背包，物品可以无限个。设置dp数组，dp[i]表示凑成总金额所需的最少的硬币个数`coin <= i时，dp[i] = Math.min(dp[i], dp[i - coin] + 1);`

```java
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);// 要求最小值，初始值就得大
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {// 倒序或者正序结果都一样，硬币可以重复且数量不限
                if (coin <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
```

#### 组合总和 Ⅳ

##### 题目描述

[原题链接](https://leetcode.cn/problems/combination-sum-iv/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/CombinationSumIV.java)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`

##### 题解

设置dp数组，dp[i]表示和为 i 的元素组合的个数，`dp[0]=1`

转换方程为`dp[i] += dp[i - num];`

```java
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int num : nums) { // 遍历数组，将所有符合要求的组合个数进行相加
                if (i >= num) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }
```

#### 买卖股票的最佳时机 III

##### 题目描述

[原题链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/BestTimeToBuyAndSellStockIII.java)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

**提示：**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^5`

##### 题解

对于每一天我们都处于五个状态中的一种：

* 未进行过任何操作；
* 只进行过一次买操作；
* 进行了一次买操作和一次卖操作，即完成了一笔交易；
* 在完成了一笔交易的前提下，进行了第二次买操作；
* 完成了全部两笔交易。

只需要考虑最后四种状态，设第一次买股票的状态为buy1；设买一次卖一次（完成了一笔交易）的状态为sell1；设在完成了一笔交易的前提下，进行了第二次买操作的状态为buy2；设完成了全部两笔交易的状态为sell2。

追求最大利润：

* 对于buy1，尽可能低价买进股票，转换方程为`buy1 = Math.min(buy1, prices[i]);`
* 对于sell1，尽可能以高价出售，转换方程为`sell1 = Math.max(sell1,prices[i]-buy1);`
* 对于buy2，第二次买股票时，同样尽可能低价买进股票，此时我们手上有第一次卖股票所获得的钱，转换方程为`buy2 = Math.min(buy2,prices[i]-sell1);`
* 对于sell2，尽可能高价出售，转换方程为`sell2 = Math.max(sell2,prices[i]-buy2);`

```java
    public int maxProfit(int[] prices) {
        int buy1 = prices[0], buy2 = prices[0];
        int sell1 = 0, sell2 = 0;
        for (int i = 1; i < prices.length; i++) {
            buy1 = Math.min(buy1, prices[i]);
            sell1 = Math.max(sell1,prices[i]-buy1);
            buy2 = Math.min(buy2,prices[i]-sell1);
            sell2 = Math.max(sell2,prices[i]-buy2);
        }
        return sell2;
    }
```

我们只关注最终的sell2，sell2->buy2->sell1->buy1，同时这四个状态也受之前的状态影响，一次交易（买一次，卖一次）利润是一个积累的过程，求出结果后并不能得出具体在哪一天买股票哪一天卖股票
