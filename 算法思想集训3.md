# 算法思想集训3

## 动态规划

### 算法思想

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：**适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）**。

动态规划的设计都有着一定的模式，一般要经历以下几个步骤：

* 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
* 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
* 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
* 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

### 分割整数

####  整数拆分

##### 题目描述

[原题链接](https://leetcode.cn/problems/integer-break/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/IntegerBreak.java)

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

 

**提示:**

- `2 <= n <= 58`

##### 题解

整数 i 拆分的最大乘积与 [2,i-1] 的最大乘积息息相关。对于具体数字10，可以将其初步拆分成1 与 9，2 与 8，……，5 与 5，并且对于 9，8，7，6，5又需要考虑是否需要继续进行拆分，考虑是否拆分的前提是我们已经知道拆分后的最大乘积与不拆分的最大乘积哪个大，最终需要对初步拆分的结果进行比较取最大值。

设置数组 dp[i] 表示 i 的最大乘积，对于 i 我们可以将其拆分为 j 与 i-j，其中 j 属于[1,i/2]。对 i-j我们需要考虑是否继续拆分，即比较`(j * (i - j))`与` j * dp[i - j]`的值，前者表示不拆分，后者表示拆分后乘积的最大值，取两者的最大值。同时由于 j 的取值并不唯一，也需要进行比较取最大值。

最终的转换方程为`dp[i] = Math.max(dp[i], Math.max((j * (i - j)), j * dp[i - j]));`

```java
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i / 2; j++) {//将i拆分成 j 与 i-j
                // j * (i - j) 表示不对 i-j 进行拆分的乘积，
                // j * dp[i - j] 表示对 i- j进行拆分
                // 取上面结果的最大值与 dp[i] 进行比较，根据 j 的取值，dp[i]会有多种结果，取其中的最大值
                dp[i] = Math.max(dp[i], Math.max((j * (i - j)), j * dp[i - j]));
            }
        }
        return dp[n];
    }
```

#### 完全平方数

##### 题目描述

[原题链接](https://leetcode.cn/problems/perfect-squares/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/PerfectSquares.java)

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

 

**提示：**

- `1 <= n <= 10^4`

##### 题解

设置数组`dp[i]`表示和为 i 的完全平方数的最少数量

对于数字 i，将 i 拆分为` j*j `与` i-j*j`，其中`j*j`是一个完全平方数，对结果的贡献值固定为1，`dp[i-j*j]`表示和为 `i-j*j` 的完全平方数的最少数量，由于 j 的取值不同会带来多种结果，取其中的最小值

```java
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int min = n;
            for (int j = 1; j * j <= i; j++) {// 将 i 拆分为 j*j 与 i-j*j
                // j*j为一个完全平方数，它的贡献值固定为1，
                // i-j*j的贡献值由于j的不同有多种结果，取其最小值
                min = Math.min(min, dp[i - j * j]);
            }
            dp[i] = min + 1;// 1为 j*j 的贡献值
        }
        return dp[n];
    }
```

#### 解码方法

##### 题目描述

[原题链接](https://leetcode.cn/problems/decode-ways/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/DecodeWays.java)

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

 

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**

```
输入：s = "06"
输出：0
解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
```

 

**提示：**

- `1 <= s.length <= 100`
- `s` 只包含数字，并且可能包含前导零。

##### 题解

对于数字 226，可以一步一步进行映射。2的解码总数为1；22的解码总数为 2，即 `[2,2]`与`[22]`；226的解码总数为3，即22的解码总数加上2的解码总数，因为226可以分为`[22,6]`与`[2,26]`

设置数组dp[i]，表示 0 到 i 位组成的字符串有多少种解码结果，初步可以得出 在第 i 位与 i-1 位组成的数字可以映射时`dp[i] = dp[i-1]+dp[i-2]`，不能映射时`dp[i] = dp[i-1]`，可以发现`dp[i]`需要根据`dp[i-1]`以及`dp[i-2]`得出，其实两个变量就可以存储了。但由于0的特殊性，情况可能会有所不同。

```java
    public int numDecodings(String s) {
        if (s.charAt(0) == '0') return 0;
        int pre1 = 1;//前一位
        int pre2 = 1;//前两位
        int dp;
        for (int i = 1; i < s.length(); i++) {
            int num = (s.charAt(i - 1) - '0') * 10 + (s.charAt(i) - '0');//组合数字
            if (s.charAt(i) != '0') {//该位不为0
                if (s.charAt(i - 1) != '0' && num >= 1 && num <= 26) {//组合数字可以映射 形如 122
                    dp = pre1 + pre2;
                } else {//不能映射 形如 206
                    dp = pre2;
                }
            } else {//该位为0
                if (s.charAt(i - 1) != '0' && num >= 1 && num <= 26) {//组合数字可以映射 形如 20
                    dp = pre1;
                } else {//不能映射 形如 60
                    return 0;
                }
            }
            pre1 = pre2;
            pre2 = dp;
        }
        return pre2;
    }
```

### 矩阵路径

#### 不同路径

##### 题目描述

[原题链接](https://leetcode.cn/problems/unique-paths/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/UniquePaths.java)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 10^9`

##### 题解

机器人每次只能向下或者向右移动一步，若设置二维数组`dp[i][j]`表示抵达坐标`(i,j)`一共有多少路径，则不越界的情况下存在递推关系`dp[i][j]=dp[i-1][j]+dp[i][j-1]`，左边界与上边界只有一条路径可达（一直向下或者一直向右）

如果我们从左往右，从上往下进行遍历，只需要一维数组进行记录即可，很多数据在遍历过程中都会失去作用（第一行对于第三行来说就没有作用），`dp[i][j]`只与`dp[i-1][j]`，`dp[i][j-1]`有关，可以映射到一行，则有`dp[j] = dp[j]+dp[j-1]`，`dp[j]`表示上一行对应 j 列的可达路径总数，`dp[j-1]`表示当前行 j-1 列的可达路径总数

```java
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 0; i <m ; i++) {
            for (int j = 1; j <n ; j++) {
                if(i==0){
                    dp[j]=dp[j-1];//一路向右
                } else {
                    dp[j] = dp[j]+dp[j-1];
                }
            }
        }
        return dp[n-1];
    }
```

#### 最小路径和

##### 题目描述

[原题链接](https://leetcode.cn/problems/minimum-path-sum/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/MinimumPathSum.java)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 100`

##### 题解

与不同路径做法相同，只需要一个一维数组进行记录即可，只不过是记录最短路径和

```java
    public int minPathSum(int[][] grid) {
        int[] dp = new int[grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (j == 0) {//一直往下
                    dp[0] = dp[0] + grid[i][0];
                } else if (i == 0) {//一直往右
                    dp[j] = dp[j - 1] + grid[0][j];
                } else {//有两种走法，取路径短的
                    dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
                }
            }
        }
        return dp[grid[0].length - 1];
    }
```

### 斐波那契数列

#### 爬楼梯

##### 题目描述

[原题链接](https://leetcode.cn/problems/climbing-stairs/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/ClimbingStairs.java)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

 

**提示：**

- `1 <= n <= 45`

##### 题解

数组数组dp[i] 表示走到第 i 个 楼梯的方法数目。第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走 到第 i-1 和第 i-2 个楼梯的方法数之和。即`dp[i]=dp[i-1]+dp[i-2]`，由于`dp[i] `只与到达前面的两个台阶方法数有关，所以只需要用两个变量进行存储，动态更新这两个变量

```java
    public int climbStairs(int n) {
        int pre1 = 0, pre2 = 1;
        for (int i = 0; i < n; i++) {
            int num = pre1 + pre2;
            pre1 = pre2;
            pre2 = num;
        }
        return pre2;
    }
```

#### 打家劫舍

##### 题目描述

[原题链接](https://leetcode.cn/problems/house-robber/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/HouseRobber.java)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

##### 题解

定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。由于不能抢劫 邻近住户，因此如果抢劫了第 i 个住户那么只能抢劫 i - 2 和 i - 3 的住户，所以`dp[i]=Math.max(dp[i-2],dp[i-3])+dp[i]`。

可以动态更新三个变量来代替数组存储

```java
    public int rob(int[] nums) {
        int pre1 = 0, pre2 = 0, pre3 = nums[0];
        int max = pre3;
        for (int i = 1; i < nums.length; i++) {
            int num = Math.max(pre1, pre2) + nums[i];
            pre1 = pre2;
            pre2 = pre3;
            pre3 = num;
            max = Math.max(max, pre3);
        }
        return max;
    }
```

#### 打家劫舍 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/house-robber-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/HouseRobberII.java)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：3
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

##### 题解

对于数组nums，起始与末尾元素只会有一个被访问（被偷），可以将数组拆分为`[0,n)`与`[1,n-1)`，n为数组元素个数，即对数组进行划分访问再比较

```java
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        return Math.max(rob(nums, 0, nums.length - 1), rob(nums, 1, nums.length));
    }

    public int rob(int[] nums, int start, int end) {
        int pre1 = 0, pre2 = 0, pre3 = nums[start];
        int max = pre3;
        for (int i = start + 1; i < end; i++) {
            int num = Math.max(pre1, pre2) + nums[i];
            pre1 = pre2;
            pre2 = pre3;
            pre3 = num;
            max = Math.max(max, pre3);
        }
        return max;
    }
```

### 最长递增子序列

#### 最长递增子序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/LongestIncreasingSubsequence.java)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

 

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

##### 题解

定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。 对于一个递增子序列 `{Si1 , Si2 ,...,Sim}`，如果` im < n 并且 Sim < Sn` ，此时 `{Si1 , Si2 ,..., Sim, Sn }` 为一个 递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列 就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 `dp[n] = max{ dp[i]+1 | Si < Sn && i < n} `。 因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 `{Sn } `就构成了递增子序列，因此需要对前面的求解方程做修改，令 dp[n] 最小为 1，

```java
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;//最小为1，自己构成一个子串
            for (int j = 0; j < i; j++) {//选取最长的
                if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            result = Math.max(result, dp[i]);
        }
        return result;
    }
```

可以使用二分查找使得时间复杂度降低为 `O(nlogn )`。定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素，例如对于数组 [4,5,6,3]，有

```
len = 1 : [4], [5], [6], [3] => tails[0] = 3
len = 2 : [4, 5], [5, 6] => tails[1] = 5
len = 3 : [4, 5, 6] => tails[2] = 6
```

对于一个元素 x，如果它大于 tails 数组所有的值，那么把它添加到 tails 后面；如果 tails[i-1] < x <= tails[i]，那么更新 tails[i] = x 。 可以看出 tails 数组保持有序，因此在查找 Si 位于 tails 数组的位置时就可以使用二分查找。

```java
    public int lengthOfLIS2(int[] nums) {
        int[] tail = new int[nums.length];
        int size = 0;//记录最长递增子序列的长度
        for (int num : nums) {
            int index = binarySearch(tail, size, num);
            tail[index] = num;
            if (index == size) size++;//已经新加了一个字符
        }
        return size;
    }
    // 二分搜索，若数组元素均大于目标值，返回0，更新下标为0的元素；
    // 均小于目标值，返回size，新加一个元素
    private int binarySearch(int[] tail, int right, int key) {
        int left = 0;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (tail[mid] == key) return mid;
            if (tail[mid] > key) right = mid;
            else left = mid + 1;
        }
        return left;
    }
```

#### 摆动序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/wiggle-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/WiggleSubsequence.java)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

 

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例 2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例 3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

##### 题解

设置两个状态up与down，up表示最后两个数字递增的最长摆动子串的长度，down表示最后两个数字递减的最长摆动子串的长度。新的down一定在up的基础上产生，新的up一定在down的基础上产生

遍历数组，出现`nums[i+1]>nums[i]`时，如果down的最后一位恰好为i，那很好理解只需要添加nums[i+1]构成新的up，如`[1,2,1,2],i为2的情景`；如果down的最后一位不为i，这里记为j，则 j 到 i 一定是递增序列，如`[4,1,5,6,7,8,9],j为1，i为5`，从下标为2到6的过程都是在down的基础上更新up，down本身其实没变，up的长度也没有改变。所以出现`nums[i+1]>nums[i]`时，`up=down+1`。同理`nums[i+1]<nums[i]`时，`down = up+1`

```java
    public int wiggleMaxLength(int[] nums) {
        int up = 1;//最后两个数字递增，需要一个较小的数字
        int down = 1;//最后两个数字递减，需要一个较大的数字
        for (int i = 0; i <nums.length-1 ; i++) {
            if(nums[i+1]>nums[i]) up = down+1;
            if(nums[i+1]<nums[i]) down = up+1;
        }
        return Math.max(up,down);
    }
```

### 最长公共子系列

对于两个子序列 S1 和 S2，找出它们最长的公共子序列。 

定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 `dp[i][j]` 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：

① 当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再 加上 S1i 这个值，最长公共子序列长度加 1 ，即 `dp[i][j] = dp[i-1][j-1] + 1`。

② 当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列， 与 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，它们的最大者，即 `dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }`。

与最长递增子序列相比，最长公共子序列有以下不同点： 

① 针对的是两个序列，求它们的最长公共子序列。 

② 在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最 长公共子序列中，`dp[i][j] `表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包 含 S1i 和 S2j 。 

③ 由于 2 ，在求最终解时，最长公共子序列中 `dp[N][M]` 就是最终解，而最长递增子序列中 dp[N] 不 是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。

#### 最长公共子序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-common-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/LongestCommonSubsequence.java)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

 

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

 

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

##### 题解

```java
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1))//相等
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else //不相等
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m][n];
    }
```

