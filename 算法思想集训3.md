# 算法思想集训3

## 动态规划

### 算法思想

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：**适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）**。

动态规划的设计都有着一定的模式，一般要经历以下几个步骤：

* 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
* 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
* 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
* 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

### 分割整数

####  整数拆分

##### 题目描述

[原题链接](https://leetcode.cn/problems/integer-break/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/IntegerBreak.java)

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

 

**提示:**

- `2 <= n <= 58`

##### 题解

整数 i 拆分的最大乘积与 [2,i-1] 的最大乘积息息相关。对于具体数字10，可以将其初步拆分成1 与 9，2 与 8，……，5 与 5，并且对于 9，8，7，6，5又需要考虑是否需要继续进行拆分，考虑是否拆分的前提是我们已经知道拆分后的最大乘积与不拆分的最大乘积哪个大，最终需要对初步拆分的结果进行比较取最大值。

设置数组 dp[i] 表示 i 的最大乘积，对于 i 我们可以将其拆分为 j 与 i-j，其中 j 属于[1,i/2]。对 i-j我们需要考虑是否继续拆分，即比较`(j * (i - j))`与` j * dp[i - j]`的值，前者表示不拆分，后者表示拆分后乘积的最大值，取两者的最大值。同时由于 j 的取值并不唯一，也需要进行比较取最大值。

最终的转换方程为`dp[i] = Math.max(dp[i], Math.max((j * (i - j)), j * dp[i - j]));`

```java
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i / 2; j++) {//将i拆分成 j 与 i-j
                // j * (i - j) 表示不对 i-j 进行拆分的乘积，
                // j * dp[i - j] 表示对 i- j进行拆分
                // 取上面结果的最大值与 dp[i] 进行比较，根据 j 的取值，dp[i]会有多种结果，取其中的最大值
                dp[i] = Math.max(dp[i], Math.max((j * (i - j)), j * dp[i - j]));
            }
        }
        return dp[n];
    }
```

#### 完全平方数

##### 题目描述

[原题链接](https://leetcode.cn/problems/perfect-squares/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/PerfectSquares.java)

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

 

**提示：**

- `1 <= n <= 10^4`

##### 题解

设置数组`dp[i]`表示和为 i 的完全平方数的最少数量

对于数字 i，将 i 拆分为` j*j `与` i-j*j`，其中`j*j`是一个完全平方数，对结果的贡献值固定为1，`dp[i-j*j]`表示和为 `i-j*j` 的完全平方数的最少数量，由于 j 的取值不同会带来多种结果，取其中的最小值

```java
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int min = n;
            for (int j = 1; j * j <= i; j++) {// 将 i 拆分为 j*j 与 i-j*j
                // j*j为一个完全平方数，它的贡献值固定为1，
                // i-j*j的贡献值由于j的不同有多种结果，取其最小值
                min = Math.min(min, dp[i - j * j]);
            }
            dp[i] = min + 1;// 1为 j*j 的贡献值
        }
        return dp[n];
    }
```

#### 解码方法

##### 题目描述

[原题链接](https://leetcode.cn/problems/decode-ways/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/DecodeWays.java)

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

 

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**

```
输入：s = "06"
输出：0
解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
```

 

**提示：**

- `1 <= s.length <= 100`
- `s` 只包含数字，并且可能包含前导零。

##### 题解

对于数字 226，可以一步一步进行映射。2的解码总数为1；22的解码总数为 2，即 `[2,2]`与`[22]`；226的解码总数为3，即22的解码总数加上2的解码总数，因为226可以分为`[22,6]`与`[2,26]`

设置数组dp[i]，表示 0 到 i 位组成的字符串有多少种解码结果，初步可以得出 在第 i 位与 i-1 位组成的数字可以映射时`dp[i] = dp[i-1]+dp[i-2]`，不能映射时`dp[i] = dp[i-1]`，可以发现`dp[i]`需要根据`dp[i-1]`以及`dp[i-2]`得出，其实两个变量就可以存储了。但由于0的特殊性，情况可能会有所不同。

```java
    public int numDecodings(String s) {
        if (s.charAt(0) == '0') return 0;
        int pre1 = 1;//前一位
        int pre2 = 1;//前两位
        int dp;
        for (int i = 1; i < s.length(); i++) {
            int num = (s.charAt(i - 1) - '0') * 10 + (s.charAt(i) - '0');//组合数字
            if (s.charAt(i) != '0') {//该位不为0
                if (s.charAt(i - 1) != '0' && num >= 1 && num <= 26) {//组合数字可以映射 形如 122
                    dp = pre1 + pre2;
                } else {//不能映射 形如 206
                    dp = pre2;
                }
            } else {//该位为0
                if (s.charAt(i - 1) != '0' && num >= 1 && num <= 26) {//组合数字可以映射 形如 20
                    dp = pre1;
                } else {//不能映射 形如 60
                    return 0;
                }
            }
            pre1 = pre2;
            pre2 = dp;
        }
        return pre2;
    }
```

### 矩阵路径

#### 不同路径

##### 题目描述

[原题链接](https://leetcode.cn/problems/unique-paths/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/UniquePaths.java)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 10^9`

##### 题解

机器人每次只能向下或者向右移动一步，若设置二维数组`dp[i][j]`表示抵达坐标`(i,j)`一共有多少路径，则不越界的情况下存在递推关系`dp[i][j]=dp[i-1][j]+dp[i][j-1]`，左边界与上边界只有一条路径可达（一直向下或者一直向右）

如果我们从左往右，从上往下进行遍历，只需要一维数组进行记录即可，很多数据在遍历过程中都会失去作用（第一行对于第三行来说就没有作用），`dp[i][j]`只与`dp[i-1][j]`，`dp[i][j-1]`有关，可以映射到一行，则有`dp[j] = dp[j]+dp[j-1]`，`dp[j]`表示上一行对应 j 列的可达路径总数，`dp[j-1]`表示当前行 j-1 列的可达路径总数

```java
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 0; i <m ; i++) {
            for (int j = 1; j <n ; j++) {
                if(i==0){
                    dp[j]=dp[j-1];//一路向右
                } else {
                    dp[j] = dp[j]+dp[j-1];
                }
            }
        }
        return dp[n-1];
    }
```

#### 最小路径和

##### 题目描述

[原题链接](https://leetcode.cn/problems/minimum-path-sum/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/MinimumPathSum.java)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 100`

##### 题解

与不同路径做法相同，只需要一个一维数组进行记录即可，只不过是记录最短路径和

```java
    public int minPathSum(int[][] grid) {
        int[] dp = new int[grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (j == 0) {//一直往下
                    dp[0] = dp[0] + grid[i][0];
                } else if (i == 0) {//一直往右
                    dp[j] = dp[j - 1] + grid[0][j];
                } else {//有两种走法，取路径短的
                    dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
                }
            }
        }
        return dp[grid[0].length - 1];
    }
```

### 斐波那契数列

#### 爬楼梯

##### 题目描述

[原题链接](https://leetcode.cn/problems/climbing-stairs/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/ClimbingStairs.java)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

 

**提示：**

- `1 <= n <= 45`

##### 题解

数组数组dp[i] 表示走到第 i 个 楼梯的方法数目。第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走 到第 i-1 和第 i-2 个楼梯的方法数之和。即`dp[i]=dp[i-1]+dp[i-2]`，由于`dp[i] `只与到达前面的两个台阶方法数有关，所以只需要用两个变量进行存储，动态更新这两个变量

```java
    public int climbStairs(int n) {
        int pre1 = 0, pre2 = 1;
        for (int i = 0; i < n; i++) {
            int num = pre1 + pre2;
            pre1 = pre2;
            pre2 = num;
        }
        return pre2;
    }
```

#### 打家劫舍

##### 题目描述

[原题链接](https://leetcode.cn/problems/house-robber/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/HouseRobber.java)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

##### 题解

定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。由于不能抢劫 邻近住户，因此如果抢劫了第 i 个住户那么只能抢劫 i - 2 和 i - 3 的住户，所以`dp[i]=Math.max(dp[i-2],dp[i-3])+dp[i]`。

可以动态更新三个变量来代替数组存储

```java
    public int rob(int[] nums) {
        int pre1 = 0, pre2 = 0, pre3 = nums[0];
        int max = pre3;
        for (int i = 1; i < nums.length; i++) {
            int num = Math.max(pre1, pre2) + nums[i];
            pre1 = pre2;
            pre2 = pre3;
            pre3 = num;
            max = Math.max(max, pre3);
        }
        return max;
    }
```

#### 打家劫舍 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/house-robber-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/dynamic_programming/HouseRobberII.java)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：3
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

##### 题解

对于数组nums，起始与末尾元素只会有一个被访问（被偷），可以将数组拆分为`[0,n)`与`[1,n-1)`，n为数组元素个数，即对数组进行划分访问再比较

```java
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        return Math.max(rob(nums, 0, nums.length - 1), rob(nums, 1, nums.length));
    }

    public int rob(int[] nums, int start, int end) {
        int pre1 = 0, pre2 = 0, pre3 = nums[start];
        int max = pre3;
        for (int i = start + 1; i < end; i++) {
            int num = Math.max(pre1, pre2) + nums[i];
            pre1 = pre2;
            pre2 = pre3;
            pre3 = num;
            max = Math.max(max, pre3);
        }
        return max;
    }
```

