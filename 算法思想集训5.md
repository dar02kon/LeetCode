# 数据结构相关（二）

## 树

### 递归

一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可 以使用递归来处理。

#### 二叉树的最大深度

##### 题目描述

[原题链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MaximumDepthOfBinaryTree.java)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

##### 题解

求树的深度可以转换成求左右子树的深度，对于左右子树的根节点同样如此

```java
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = maxDepth(root.left) + 1; // 求左子树的深度
        int right = maxDepth(root.right) + 1; // 求右子树的深度
        return Math.max(left, right); // 返回最大深度
    }
```

也可以使用队列来进行层次遍历找到最大深度

```java
    public int maxDepth2(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int count = 0;
        while (!queue.isEmpty()) {
            int size = queue.size(); // 这一层的节点数，防止后面添加的节点产生干扰
            while (size-- > 0) { // 遍历这一层的节点
                TreeNode poll = queue.poll();
                // 添加下一层的节点
                if(poll.left!=null) queue.offer(poll.left); 
                if(poll.right!=null) queue.offer(poll.right);
            }
            count++; // 计数
        }
        return count;
    }
```

#### 翻转二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/invert-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/InvertBinaryTree.java)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

##### 题解

递归交换每一个节点的左子树与右子树

```java
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        TreeNode left = invertTree(root.left); // 对左子树进行反转
        TreeNode right = invertTree(root.right); // 对右子树进行反转
        // 交换左右子树
        root.left = right;
        root.right = left;
        return root;
    }
```

保证每一个节点的左子树与右子树都能交换的非递归写法

```java
    public TreeNode invertTree2(TreeNode root) {
        if(root==null){
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            TreeNode poll = queue.poll();
            // 添加新的节点
            if(poll.left!=null){
                queue.offer(poll.left);
            }
            if(poll.right!=null){
                queue.offer(poll.right);
            }
            // 交换该节点的左右子树
            TreeNode temp = poll.left;
            poll.left = poll.right;
            poll.right = temp;
        }
        return root;
    }
```

#### 合并二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/merge-two-binary-trees/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MergeTwoBinaryTrees.java)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

 

**提示：**

- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-10^4 <= Node.val <= 10^4`

##### 题解

判断两棵树对应节点的情况，如果均不为空，该处的节点的值应为两节点值的和；有一方为空，应为不为空的节点；均为空则为null

判断每一处对应节点的情况后，递归合并左右子树

```java
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return null;
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        TreeNode root = new TreeNode(root1.val + root2.val); // 节点均不为空，求和
        root.left = mergeTrees(root1.left, root2.left); // 递归合并左子树
        root.right = mergeTrees(root1.right, root2.right); // 递归合并右子树
        return root; // 返回根节点
    }
```

#### 路径总和

##### 题目描述

[原题链接](https://leetcode.cn/problems/path-sum/description/)

[原题链接](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/PathSum.java)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

 

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

##### 题解

递归判断root左子树或右子树的和是否为`targetSum-root.val`

```java
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        return check(root,targetSum);
    }
    public boolean check(TreeNode root, int targetSum) {
        if(root.left==null&&root.right==null){ // 叶子节点
            return targetSum-root.val==0;
        }
        if(root.left!=null&&root.right!=null){ // 左右子树均存在
            return check(root.left,targetSum-root.val) || check(root.right,targetSum-root.val);
        } else if(root.left!=null){ // 左子树
            return check(root.left,targetSum-root.val);
        } else { //右子树
            return check(root.right,targetSum-root.val);
        }
    }
```

简写

```java
    public boolean hasPathSum2(TreeNode root, int targetSum) {
        if(root==null){ // root为null时，root不可能为叶子节点
            return false;
        }
        // 判断到达此叶子节点的路径和是否满足要求
        if(root.left==null&&root.right==null&&root.val==targetSum) return true; 
        // 递归判断左子树与右子树
        return hasPathSum2(root.left,targetSum-root.val) || hasPathSum2(root.right,targetSum-root.val);
    }
```

非递归写法（使用队列进行辅助）

```java
    public boolean hasPathSum3(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        Queue<TreeNode> nodeQueue = new LinkedList<>(); // 存储节点
        Queue<Integer> sumQueue = new LinkedList<>(); // 存储和，与节点对应
        nodeQueue.offer(root);
        sumQueue.add(root.val);
        while (!nodeQueue.isEmpty()){
            TreeNode node = nodeQueue.poll();
            int sum = sumQueue.poll();
            if(node.left==null&&node.right==null){ // 叶子节点
                if(sum==targetSum)
                    return true;
            }
            // 添加节点与其对应的路径和
            if(node.left!=null){
                nodeQueue.offer(node.left);
                sumQueue.offer(sum+node.left.val);
            }
            if(node.right!=null){
                nodeQueue.offer(node.right);
                sumQueue.offer(sum+node.right.val);
            }
        }
        return false;
    }
```

#### 对称二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/symmetric-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SymmetricTree.java)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

##### 题解

递归判断左子树与右子树节点是否对应相同

```java
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return check(root.left, root.right); // 左右子树
    }

    public boolean check(TreeNode left, TreeNode right) {
        if (left == null && right == null) return true; // 均为空
        // 对应节点不相同
        if (left == null || right == null) return false; 
        if (left.val != right.val) return false;
        // 继续进行对称判断
        return check(left.left, right.right) && check(left.right, right.left);
    }
```

非递归写法（使用队列进行辅助）

```java
    public boolean isSymmetric2(TreeNode root) {
        if (root == null) {
            return true;
        }
        Queue<TreeNode> queue = new LinkedList<>(); // 存储节点
        queue.offer(root.left);
        queue.offer(root.right);
        while (!queue.isEmpty()) {
            TreeNode left = queue.poll(); // 左子树
            TreeNode right = queue.poll(); // 右子树
            if (left == null && right == null) continue; // 均为空，继续判断
            // 对应节点不相同
            if (left == null || right == null) return false;
            if (left.val != right.val) return false;
            // 添加对应节点，先左后右
            queue.offer(left.left);
            queue.offer(right.right);
            queue.offer(left.right);
            queue.offer(right.left);
        }
        return true;
    }
```

#### 平衡二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/balanced-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/BalancedBinaryTree.java)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```

 

**提示：**

- 树中的节点数在范围 `[0, 5000]` 内
- `-10^4 <= Node.val <= 10^4`

##### 题解

递归求解左右子树的深度进行比较，相差大于1则肯定不为高度平衡二叉树

```java
    public boolean isBalanced(TreeNode root) {
        check(root);
        return result;
    }
    boolean result = true;
    public int check(TreeNode root) {
        if(root==null){
            return 0;
        }
        int left = check(root.left)+1;
        int right = check(root.right)+1;
        if(right-left>1||left-right>1){ // 左右子树深度相差大于1
            result = false;
        }
        return Math.max(right,left);
    }
```

#### 二叉树的最小深度

##### 题目描述

[原题链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MinimumDepthOfBinaryTree.java)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

 

**提示：**

- 树中节点数的范围在 `[0, 10^5]` 内
- `-1000 <= Node.val <= 1000`

##### 题解

可以递归求解左右子树的深度，左右子树均存在，则取最小深度，有一方不存在选择存在那一方的深度（最大深度）

```java
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = minDepth(root.left);
        int right = minDepth(root.right);
        if (root.left != null && root.right != null) {
            return Math.min(left, right) + 1;
        } else {
            return Math.max(left, right) + 1;
        }
    }
```

因为是求最小深度，层次遍历要更好一些，可以及时返回

```java
    public int minDepth2(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int result = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            result++;
            while (size-- > 0) { // 遍历一层
                TreeNode node = queue.poll();
                if (node.left == null && node.right == null) { // 叶子节点
                    return result;
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return result;
    }
```

#### 左叶子之和

##### 题目描述

[原题链接](https://leetcode.cn/problems/sum-of-left-leaves/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SumOfLeftLeaves.java)

给定二叉树的根节点 `root` ，返回所有左叶子之和。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**示例 2:**

```
输入: root = [1]
输出: 0
```

 

**提示:**

- 节点数在 `[1, 1000]` 范围内
- `-1000 <= Node.val <= 1000`

##### 题解

递归求解，通过参数来判断叶子节点是否为左叶子节点

```java
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }
        check(root.left, true);
        check(root.right, false);
        return result;
    }

    int result = 0;

    public void check(TreeNode root, boolean flag) {
        if (root == null) {
            return;
        }
        if (root.left == null && root.right == null) { // 叶子节点
            if (flag) { // 左叶子节点
                result += root.val;
            }
        }
        // 继续递归判断
        if (root.left != null) {
            check(root.left, true);
        }
        if (root.right != null) {
            check(root.right, false);
        }
    }
```

#### 修剪二叉搜索树

##### 题目描述

[原题链接](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/TrimABinarySearchTree.java)

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)

```
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)

```
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
```

 

**提示：**

- 树中节点数在范围 `[1, 104]` 内
- `0 <= Node.val <= 10^4`
- 树中每个节点的值都是 **唯一** 的
- 题目数据保证输入是一棵有效的二叉搜索树
- `0 <= low <= high <= 10^4`

##### 题解

题目所给的树是一棵有效的二叉搜索树，所以对于节点 root，如果`root.val>high`，则root的右子树全部都大于high，需要删除；如果`root.val<low`，则root的左子树全部都小于low，需要删除

```java
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) {
            return null;
        }
        if (root.val > high) return trimBST(root.left, low, high); // 删除右子树
        if (root.val < low) return trimBST(root.right, low, high); // 删除左子树
        root.left = trimBST(root.left, low, high); // 递归删除左子树不符合要求的节点
        root.right = trimBST(root.right, low, high); // 递归删除右子树不符号要求的节点
        return root;
    }
```

#### 另一棵树的子树

##### 题目描述

[原题链接](https://leetcode.cn/problems/subtree-of-another-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SubtreeOfAnotherTree.java)

给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg)

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg)

```
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
```

 

**提示：**

- `root` 树上的节点数量范围是 `[1, 2000]`
- `subRoot` 树上的节点数量范围是 `[1, 1000]`
- `-10^4 <= root.val <= 10^4`
- `-10^4 <= subRoot.val <= 10^4`

##### 题解

需要找到以某一节点为根节点的树与`subRoot`完全相同，假设这个根节点为root，先判断根节点是否相同，如何递归判断左子树与右子树是否相同。我们只需要遍历整个树，尝试寻找这样的根节点即可

```java
    public boolean isSubtree2(TreeNode root, TreeNode subRoot) { 
        if (root == null && subRoot == null) return true;
        if (root == null || subRoot == null) return false;
        if (root.val == subRoot.val && check(root, subRoot)) return true; // 根节点相同，判断整棵树是否完全相同
        // 判断左子树与右子树是否与目标树相同
        return isSubtree2(root.left, subRoot) || isSubtree2(root.right, subRoot); 
    }

    public boolean check(TreeNode root, TreeNode subRoot) { // 判断这两棵树是否完全相同
        if (root == null && subRoot == null) return true;
        if (root == null || subRoot == null) return false;
        if (root.val != subRoot.val) return false;
        return check(root.left, subRoot.left) && check(root.right, subRoot.right);
    }
```

遍历每一个节点可以不用递归方式来写

```java
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        Queue<TreeNode> queue = new LinkedList<>();
        if (root == null && subRoot == null) return true;
        if (root == null || subRoot == null) return false;
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode poll = queue.poll();
            if (check(poll, subRoot)) return true;
            if (poll.left != null) {
                queue.offer(poll.left);
            }
            if (poll.right != null) {
                queue.offer(poll.right);
            }

        }
        return false;
    }

    public boolean check(TreeNode root, TreeNode subRoot) {
        if (root == null && subRoot == null) return true;
        if (root == null || subRoot == null) return false;
        if (root.val != subRoot.val) return false;
        return check(root.left, subRoot.left) && check(root.right, subRoot.right);
    }

```

#### 将有序数组转换为二叉搜索树

##### 题目描述

[原题链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ConvertSortedArrayToBinarySearchTree.java)

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

 

**提示：**

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 按 **严格递增** 顺序排列

##### 题解

二叉搜索树与二分搜索有很多渊源，我们可以利用二分搜索来构建节点

```java
    public TreeNode sortedArrayToBST(int[] nums) {
        return create(nums, 0, nums.length - 1);
    }

    public TreeNode create(int[] nums, int left, int right) {
        if (left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = create(nums, left, mid - 1); // 构建左子树
        root.right = create(nums, mid + 1, right); // 构建右子树
        return root;
    }
```

#### 二叉树的直径

##### 题目描述

[原题链接](https://leetcode.cn/problems/diameter-of-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/DiameterOfBinaryTree.java)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

 

**注意：**两结点之间的路径长度是以它们之间边的数目表示。

##### 题解

对于节点root，将其左子树的最长路径+右子树的最长路径即为经过root的最长路径，对于每一个节点都做同样的操作取最大值即可

```java
    int max = 0;
    // 统计节点数
    public int diameterOfBinaryTree(TreeNode root) {
        check(root);
        return max-2; // 节点数存在重复
    }
    public int check(TreeNode root){
        if(root==null) return 0;
        int left = check(root.left)+1; // 左子树的节点数
        int right = check(root.right)+1; // 右子树的节点数
        max = Math.max(max,left+right+1); // 比较
        return Math.max(left,right); // 返回较大的长度
    }
```

在返回时进行路径+1操作即可避免节点的统计重复

```java
    int max = 0;
    // 统计路径数
    public int diameterOfBinaryTree2(TreeNode root) {
        check2(root);
        return max;
    }
    public int check2(TreeNode root){
        if(root==null) return 0;
        int left = check2(root.left);
        int right = check2(root.right);
        max = Math.max(max,left+right);
        return Math.max(left,right)+1;
    }
```

#### 二叉树中第二小的节点

##### 题目描述

[原题链接](https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SecondMinimumNodeInABinaryTree.java)

给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 `2` 或 `0`。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

更正式地说，即 `root.val = min(root.left.val, root.right.val)` 总成立。

给出这样的一个二叉树，你需要输出所有节点中的 **第二小的值** 。

如果第二小的值不存在的话，输出 -1 **。**

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg)

```
输入：root = [2,2,5,null,null,5,7]
输出：5
解释：最小的值是 2 ，第二小的值是 5 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg)

```
输入：root = [2,2,2]
输出：-1
解释：最小的值是 2, 但是不存在第二小的值。
```

 

**提示：**

- 树中节点数目在范围 `[1, 25]` 内
- `1 <= Node.val <= 231 - 1`
- 对于树中每个节点 `root.val == min(root.left.val, root.right.val)`

##### 题解

一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点。对于节点root，假设其存在子节点，则root则为最小节点，若root的左节点与root相同，则第二小节点可能在左子树中；若不相同，则左节点可能为第二小节点（左子树中不会有比它再小的值），对于右节点同样如此。

```java
    public int findSecondMinimumValue(TreeNode root) {
        if (root == null) return -1; // 空树
        if (root.left == null && root.right == null) return -1; // 不存在第二小节点
        int left = root.left.val; // 左节点的值
        int right = root.right.val; // 右节点的值
        // 搜索与根节点相同的子节点对应的子树来寻找第二小节点
        if (root.val == left) left = findSecondMinimumValue(root.left);
        if (root.val == right) right = findSecondMinimumValue(root.right);
        // 返回较小值
        if (left != -1 && right != -1) return Math.min(left, right);
        return left != -1 ? left : right;
    }
```

#### 二叉搜索树的最近公共祖先

##### 题目描述

[原题链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/LowestCommonAncestorOfABinarySearchTree.java)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

 

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

 

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

##### 题解

当p，q第一次分居root两侧（包括等于），则root即为p，q的最近公共祖先

```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if((p.val<=root.val&&q.val>=root.val)||(p.val>=root.val&&q.val<=root.val)){ // 分居两侧
            return root;
        }
        // p，q均在左侧
        if(p.val<root.val) return lowestCommonAncestor(root.left,p,q);
        // p，q均在右侧
        return lowestCommonAncestor(root.right,p,q);
    }
```

#### 二叉树的最近公共祖先

##### 题目描述

[原题链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/LowestCommonAncestorOfABinaryTree.java)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

 

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-10^9 <= Node.val <= 10^9`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

##### 题解

对于节点root（与p，q均不相同），搜索它的左子树与右子树，当遇到p，q就返回相应的节点。若p，q在左右子树中，则返回root（公共祖先），只在一侧，返回对应的节点。

```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null||root.val==p.val||root.val==q.val) return root; // 遇见就返回
        TreeNode left = lowestCommonAncestor(root.left, p, q); // 搜索左子树
        TreeNode right = lowestCommonAncestor(root.right, p, q); // 搜索右子树
        return left==null?right:(right==null?left:root); // 尝试返回公共祖先，不为空的节点
    }
```

#### 最长同值路径

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-univalue-path/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/LongestUnivaluePath.java)

给定一个二叉树的 `root` ，返回 *最长的路径的长度* ，这个路径中的 *每个节点具有相同值* 。 这条路径可以经过也可以不经过根节点。

**两个节点之间的路径长度** 由它们之间的边数表示。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg)

```
输入：root = [5,4,5,1,1,5]
输出：2
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg)

```
输入：root = [1,4,5,4,4,5]
输出：2
```

 

**提示:**

- 树的节点数的范围是 `[0, 10^4]` 
- `-1000 <= Node.val <= 1000`
- 树的深度将不超过 `1000` 

##### 题解

对于节点root，判断其左右节点的值是否与它相同，若相同以同样的方式往下判断，统计路径值；若不相同，以不相同的节点为新的root继续判断

```java
    int max = 0;
    public int longestUnivaluePath(TreeNode root) {
        if (root == null) return 0;
        check(root, root.val);
        return max;
    }

    public int check(TreeNode root, int val) {
        if (root == null) return 0;
        if (root.val != val) { // 节点不相同
            check(root, root.val); // 以不相同的节点为root，重新递归判断
            return 0;
        }
        int left = check(root.left, val); // 递归判断左节点
        int right = check(root.right, val); // 递归判断右节点
        max = Math.max(max, left + right); // 路径和
        return Math.max(left, right) + 1; // 返回左右子树的最长路径
    }
```

#### 打家劫舍 III

##### 题目描述

[原题链接](https://leetcode.cn/problems/house-robber-iii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/HouseRobberIII.java)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```

 

**提示：**



- 树的节点数在 `[1, 10^4]` 范围内
- `0 <= Node.val <= 10^4`

##### 题解

对于节点root，如果节点root被选择，则root的左右节点均不能被选择；若root没有被选择，则其左右节点可被选择也可不选择。

用 `f(root)`表示选择 root 节点的情况下，root 节点的子树上被选择的节点的最大权值和；`g(root)` 表示不选择 root 节点的情况下，root 节点的子树上被选择的节点的最大权值和；left 和 right 代表 root 的左右孩子。

* 当 root 被选中时，root 的左右孩子都不能被选中，故 root 被选中情况下子树上被选中点的最大权值和为 left 和 right 不被选中的最大权值和相加，即 `f(root)=g(left)+g(right)`
* 当 root 不被选中时，root 的左右孩子可以被选中，也可以不被选中。对于 root 的某个具体的孩子 x，它对 root 的贡献是 x 被选中和不被选中情况下权值和的较大值。故 `g(root)=Math.max(f(left),g(left))+Math.max(f(right),g(right))`


对于上一次，只关心下一层选和不选的最大值，可以返回一个容量为2数组`nums`，`nums[0]`表示选择了对应的最大值，`nums[1]`表示不选择对应的最大值

```java
    public int rob(TreeNode root) {
        int[] check = check(root);
        return Math.max(check[0],check[1]);
    }

    public int[] check(TreeNode root){
        if(root==null) return new int[]{0,0};
        int[] left = check(root.left);
        int[] right = check(root.right);
        // 选择了root，不能再选其左右节点
        int selected = root.val + left[1]+right[1]; 
        // 未选择root，其左右节点可选也可不选，取最大值
        int notSelected = Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        // 返回结果给上一层，下标0，1分别对应选择和不选择
        return new int[]{selected,notSelected};
    }
```

### 层次遍历 

使用 BFS 进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开 始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就 能保证这次遍历的都是当前层的节点。

####  二叉树的层平均值

##### 题目描述

[原题链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/AverageOfLevelsInBinaryTree.java)

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg)

```
输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]
```

 

**提示：**



- 树中节点数量在 `[1, 104]` 范围内
- `-2^31 <= Node.val <= 2^31 - 1`

##### 题解

层次遍历，求每一层的平均值

```java
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> list = new ArrayList<>();
        if(root==null) return list;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()){ 
            int size = queue.size(); // 每一层的元素个数
            int count = size;
            double sum = 0;
            while (size-- >0){ // 遍历一层
                TreeNode node = queue.poll();
                sum+=node.val;
                if(node.left!=null){
                    queue.add(node.left);
                }
                if(node.right!=null){
                    queue.add(node.right);
                }
            }
            list.add(sum/count);
        }
        return list;
    }
```

#### 找树左下角的值

##### 题目描述

[原题链接](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/FindBottomLeftTreeValue.java)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)

```
输入: root = [2,1,3]
输出: 1
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)

```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

 

**提示:**

- 二叉树的节点个数的范围是 `[1,104]`
- `-2^31 <= Node.val <= 2^31 - 1` 

##### 题解

层次遍历，每一层遍历需要记录第一个值，最后一层的第一个值即为要找的结果

```java
    // 层次遍历 从左往右
    public int findBottomLeftValue(TreeNode root) {
        if (root == null) return -1;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int result = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            int count = size - 1;
            while (size-- > 0) {
                TreeNode node = queue.poll();
                if (size == count) { // 记录第一个值
                    result = node.val;
                }
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
        }
        return result;
    }
```

层次遍历时，可以选择从右往左遍历每一层，这样最后遍历的那个节点就是我们要找的值

```java
    // 层次遍历 从右往左
    public int findBottomLeftValue2(TreeNode root) {
        if (root == null) return -1;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            root = queue.poll();
            if (root.right != null) {
                queue.add(root.right);
            }
            if (root.left != null) {
                queue.add(root.left);
            }
        }
        return root.val;
    }
```

### 前中后序遍历

#### 二叉树的前序遍历

##### 题目描述

[原题链接](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/BinaryTreePreorderTraversal.java)

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
输入：root = [1,2]
输出：[1,2]
```

**示例 5：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
输入：root = [1,null,2]
输出：[1,2]
```

 

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

##### 题解

非递归实现二叉树的前序遍历

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root==null) return list;
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode pop = stack.pop();
            list.add(pop.val);
            if(pop.right!=null) stack.push(pop.right);
            // // 先添加右子树再添加左子树，这样是为了让左子树在栈顶
            if(pop.left!=null) stack.push(pop.left);
        }
        return list;
    }
```

#### 二叉树的后序遍历

##### 题目描述

[原题链接](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/BinaryTreePostorderTraversal.java)

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)

```
输入：root = [1,null,2,3]
输出：[3,2,1]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

 

**提示：**

- 树中节点的数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

##### 题解

前序遍历为 root -> left -> right，后序遍历为 left -> right -> root，可以修改前序遍历成为 root -> right - > left，那么这个顺序就和后序遍历正好相反。

```java
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root==null) return list;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode pop = stack.pop();
            list.add(pop.val);
            // 先左后右入栈，遍历顺序为先右后左
            if(pop.left!=null) stack.push(pop.left);
            if(pop.right!=null) stack.push(pop.right);
        }
        Collections.reverse(list);
        return list;
    }
```

#### 二叉树的中序遍历

##### 题目描述

[原题链接](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/BinaryTreeInorderTraversal.java)

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

 

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

##### 题解

非递归实现二叉树的中序遍历

```java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode p = root;
        while (p != null || !stack.isEmpty()) {
            while (p != null) {// 模拟递归栈的不断深入
                stack.push(p);
                p = p.left;
            }
            TreeNode pop = stack.pop();
            list.add(pop.val);
            p = pop.right;
        }
        return list;
    }
```

### BST

#### 两数之和 IV - 输入二叉搜索树

##### 题目描述

[原难链接](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/TwoSumIVInputIsABst.java)

给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg)

```
输入: root = [5,3,6,2,4,null,7], k = 9
输出: true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg)

```
输入: root = [5,3,6,2,4,null,7], k = 28
输出: false
```

 

**提示:**

- 二叉树的节点个数的范围是 `[1, 104]`.
- `-10^4 <= Node.val <= 10^4`
- 题目数据保证，输入的 `root` 是一棵 **有效** 的二叉搜索树
- `-10^5 <= k <= 10^5`

##### 题解

使用中序遍历得到有序数组之后，再利用双指针对数组进行查找

```java
    public boolean findTarget(TreeNode root, int k) {
        List<Integer> list = new ArrayList<>();
        inOrder(root,list);
        int left = 0,right = list.size()-1;
        while (left<right){ // 双指针
            int sum = list.get(left)+list.get(right);
            if(sum==k){
                return true;
            } else if(sum>k){
                right--;
            } else {
                left++;
            }
        }
        return false;
    }

	// 中序遍历
    public void inOrder(TreeNode root,List<Integer> list){
        if(root==null) return;
        inOrder(root.left,list);
        list.add(root.val);
        inOrder(root.right,list);
    }
```

#### 二叉搜索树的最小绝对差

##### 题目描述

[原题链接](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MinimumAbsoluteDifferenceInBST.java)

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)

```
输入：root = [4,2,6,1,3]
输出：1
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)

```
输入：root = [1,0,48,null,null,12,49]
输出：1
```

 

**提示：**

- 树中节点的数目范围是 `[2, 104]`
- `0 <= Node.val <= 10^5`

 

##### 题解

利用 BST 的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值

```java
    int min = Integer.MAX_VALUE;
    int pre = -1;
    public int getMinimumDifference(TreeNode root) {
      inOrder(root);
      return min;
    }
  
    // 中序遍历 
    private void inOrder(TreeNode root) {
        if(root==null) return;
        inOrder(root.left);
        if(pre!=-1) min = Math.min(min, Math.abs(root.val - pre));
        pre = root.val;
        inOrder(root.right);
    }
```

#### 把二叉搜索树转换为累加树

##### 题目描述

[原题链接](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ConvertBstToGreaterTree.java)

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png)**

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

**示例 2：**

```
输入：root = [0,null,1]
输出：[1,null,1]
```

**示例 3：**

```
输入：root = [1,0,2]
输出：[3,3,2]
```

**示例 4：**

```
输入：root = [3,2,4,1]
输出：[7,9,4,10]
```

 

**提示：**

- 树中的节点数介于 `0` 和 `104` 之间。
- 每个节点的值介于 `-10^4` 和 `10^4` 之间。
- 树中的所有值 **互不相同** 。
- 给定的树为二叉搜索树。

##### 题解

二叉搜索树的中序遍历（左中右）会得到一个升序序列，反过来，右中左进行遍历就可以得到降序序列，根据降序序列进行累加就可以得到每个节点 `node` 的新值即原树中大于或等于 `node.val` 的值之和。

```java
    public TreeNode convertBST(TreeNode root) {
        add(root);
        return root;
    }
    int sum = 0; // 记录和
    public void add(TreeNode root) {
        if (root == null) return;
        if (root.right != null) { // 递归遍历右子树
            add(root.right);
        }
        sum += root.val; // 累加
        root.val = sum;
        if (root.left != null) { // 递归遍历左子树
            add(root.left);
        }
    }
```

####  二叉搜索树中的众数

##### 题目描述

[原题链接](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/FindModeInBinarySearchTree.java)

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg)

```
输入：root = [1,null,2,2]
输出：[2]
```

**示例 2：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中节点的数目在范围 `[1, 10^4]` 内
- `-10^5 <= Node.val <= 10^5`

##### 题解

二叉搜索树的中序遍历是升序的

```java
    int max = Integer.MIN_VALUE; // 最大数
    int count = 0; // 计数
    int pre = Integer.MIN_VALUE; // 记录前一个节点的值
    List<Integer> list = new ArrayList<>();
    public int[] findMode(TreeNode root) {
        inOrder(root);
        int[] result = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }

    public void inOrder(TreeNode root) {
        if (root == null) return;
        // 中序遍历左子树
        inOrder(root.left);
        if (pre == Integer.MIN_VALUE) {
            pre = root.val;
        }
        if (pre == root.val) {
            count++;
        } else {
            count = 1;
        }
        if (count > max) { // 更新众数
            list.clear();
            list.add(root.val);
            max = count;
        } else if (count == max) {
            list.add(root.val);
        }
        pre = root.val;
        // 中序遍历右子树
        inOrder(root.right);
    }
```

#### 二叉搜索树中第K小的元素

##### 题目描述

[原题链接](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/KthSmallestElementInABst.java)

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

 

 

**提示：**

- 树中的节点数为 `n` 。
- `1 <= k <= n <= 10^4`
- `0 <= Node.val <= 10^4`

##### 题解 

二叉搜索树中序遍历是升序序列

```java
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<>();
        while (!stack.isEmpty()||root!=null){
            while (root!=null){ // 一直向左
                stack.add(root);
                root = root.left;
            }
            root = stack.pop();
            if(k==1) return root.val;
            k--;
            root = root.right;
        }
        return -1;
    }
```

利用二叉搜索树树的性质，左子树的值比节点小，右子树的值比节点大进行递归搜索

```java
    public int kthSmallest2(TreeNode root, int k) {
        // 统计左子树节点的个数
        int count = count(root.left);
        if(count==k-1) return root.val;
        // 目标值在左子树中
        if(count>k-1) return kthSmallest2(root.left,k);
        // 目标值在右子树中
        return kthSmallest2(root.right,k-count-1);
    }

 	// 搜索节点个数
    public int count(TreeNode root){
        if(root==null) return 0;
        return count(root.left)+count(root.right)+1;
    }
```

### Trie

#### 实现 Trie (前缀树)

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementTriePrefixTree.java)

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

**提示：**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 10^4` 次

##### 题解

从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：

* 子节点存在。沿着指针移动到子节点，继续处理下一个字符。
* 子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。

重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。

我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：

* 子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
* 子节点不存在。说明字典树中不包含该前缀，返回空指针。

重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。

若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。

```java
public class ImplementTriePrefixTree {

    public static void main(String[] args) {

    }


}
class Trie {
    private static class Node{
        Node[] children = new Node[26];
        boolean isEnd;
    }
    private final Node root = new Node();
    public Trie() {

    }

    public void insert(String word) {
        Node node = root;
        for (int i = 0; i <word.length() ; i++) { // 逐个插入
            int index = word.charAt(i)-'a';
            if(node.children[index]==null){
                node.children[index] = new Node();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }

    public boolean search(String word) {
        Node node = searchPrefix(word);
        return node!=null&&node.isEnd;
    }

    public boolean startsWith(String prefix) {
        return searchPrefix(prefix)!=null;
    }

    private Node searchPrefix(String prefix){ // 沿着路径进行判断字符是否存在
        Node node = root;
        for (int i = 0; i < prefix.length(); i++) {
            int index = prefix.charAt(i)-'a';
            if(node.children[index]==null) return null;
            node = node.children[index];
        }
        return node;
    }
}
```

#### 键值映射

##### 题目描述

[原题链接](https://leetcode.cn/problems/map-sum-pairs/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MapSumPairs.java)

设计一个 map ，满足以下几点:

- 字符串表示键，整数表示值
- 返回具有前缀等于给定字符串的键的值的总和

实现一个 `MapSum` 类：

- `MapSum()` 初始化 `MapSum` 对象
- `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key` ，整数表示值 `val` 。如果键 `key` 已经存在，那么原来的键值对 `key-value` 将被替代成新的键值对。
- `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。

 

**示例 1：**

```
输入：
["MapSum", "insert", "sum", "insert", "sum"]
[[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
输出：
[null, null, 3, null, 5]

解释：
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);  
mapSum.sum("ap");           // 返回 3 (apple = 3)
mapSum.insert("app", 2);    
mapSum.sum("ap");           // 返回 5 (apple + app = 3 + 2 = 5)
```

 

**提示：**

- `1 <= key.length, prefix.length <= 50`
- `key` 和 `prefix` 仅由小写英文字母组成
- `1 <= val <= 1000`
- 最多调用 `50` 次 `insert` 和 `sum`

##### 题解

建立前缀树，找到前缀的最后一个字符的位置，进行深搜

```java
public class MapSumPairs {

    public static void main(String[] args) {

    }

}
class MapSum {

    private static class Tire{
        int val;
        Map<Character,Tire> children = new HashMap<>();
        boolean isEnd;
    }
    private final Tire root = new Tire();
    public MapSum() {

    }

    public void insert(String key, int val) {
        Tire node = root;
        for (int i = 0; i <key.length() ; i++) {
            char index = key.charAt(i);
            if(!node.children.containsKey(index)){
                Tire next = new Tire();
                node.children.put(index,next);
            }
            node = node.children.get(index);
        }
        node.val = val;
        node.isEnd = true;
    }

    public int sum(String prefix) {
        Tire node = root;
        // 找到前缀对应的最后一个字符
        for (int i = 0; i < prefix.length(); i++) {
            char index = prefix.charAt(i);
            if(!node.children.containsKey(index)){
                return 0;
            }
            node = node.children.get(index);
        }
        return dfs(node);
    }

    // 根据前缀最后一个字符的位置向后深搜（后面的字符串肯定包含该前缀）
    private int dfs(Tire node) {
        int sum = 0;
        if(node.isEnd){
            sum+=node.val;
        }
        for (Tire tire : node.children.values()) {
            sum+=dfs(tire);
        }
        return sum;
    }
}

```

