# 数据结构相关（二）

## 树

### 递归

一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可 以使用递归来处理。

#### 二叉树的最大深度

##### 题目描述

[原题链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MaximumDepthOfBinaryTree.java)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

##### 题解

求树的深度可以转换成求左右子树的深度，对于左右子树的根节点同样如此

```java
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = maxDepth(root.left) + 1; // 求左子树的深度
        int right = maxDepth(root.right) + 1; // 求右子树的深度
        return Math.max(left, right); // 返回最大深度
    }
```

也可以使用队列来进行层次遍历找到最大深度

```java
    public int maxDepth2(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int count = 0;
        while (!queue.isEmpty()) {
            int size = queue.size(); // 这一层的节点数，防止后面添加的节点产生干扰
            while (size-- > 0) { // 遍历这一层的节点
                TreeNode poll = queue.poll();
                // 添加下一层的节点
                if(poll.left!=null) queue.offer(poll.left); 
                if(poll.right!=null) queue.offer(poll.right);
            }
            count++; // 计数
        }
        return count;
    }
```

#### 翻转二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/invert-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/InvertBinaryTree.java)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

##### 题解

递归交换每一个节点的左子树与右子树

```java
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        TreeNode left = invertTree(root.left); // 对左子树进行反转
        TreeNode right = invertTree(root.right); // 对右子树进行反转
        // 交换左右子树
        root.left = right;
        root.right = left;
        return root;
    }
```

保证每一个节点的左子树与右子树都能交换的非递归写法

```java
    public TreeNode invertTree2(TreeNode root) {
        if(root==null){
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            TreeNode poll = queue.poll();
            // 添加新的节点
            if(poll.left!=null){
                queue.offer(poll.left);
            }
            if(poll.right!=null){
                queue.offer(poll.right);
            }
            // 交换该节点的左右子树
            TreeNode temp = poll.left;
            poll.left = poll.right;
            poll.right = temp;
        }
        return root;
    }
```

#### 合并二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/merge-two-binary-trees/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MergeTwoBinaryTrees.java)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

 

**提示：**

- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-10^4 <= Node.val <= 10^4`

##### 题解

判断两棵树对应节点的情况，如果均不为空，该处的节点的值应为两节点值的和；有一方为空，应为不为空的节点；均为空则为null

判断每一处对应节点的情况后，递归合并左右子树

```java
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return null;
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        TreeNode root = new TreeNode(root1.val + root2.val); // 节点均不为空，求和
        root.left = mergeTrees(root1.left, root2.left); // 递归合并左子树
        root.right = mergeTrees(root1.right, root2.right); // 递归合并右子树
        return root; // 返回根节点
    }
```

