# 数据结构相关（二）

## 树

### 递归

一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可 以使用递归来处理。

#### 二叉树的最大深度

##### 题目描述

[原题链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MaximumDepthOfBinaryTree.java)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

##### 题解

求树的深度可以转换成求左右子树的深度，对于左右子树的根节点同样如此

```java
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = maxDepth(root.left) + 1; // 求左子树的深度
        int right = maxDepth(root.right) + 1; // 求右子树的深度
        return Math.max(left, right); // 返回最大深度
    }
```

也可以使用队列来进行层次遍历找到最大深度

```java
    public int maxDepth2(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int count = 0;
        while (!queue.isEmpty()) {
            int size = queue.size(); // 这一层的节点数，防止后面添加的节点产生干扰
            while (size-- > 0) { // 遍历这一层的节点
                TreeNode poll = queue.poll();
                // 添加下一层的节点
                if(poll.left!=null) queue.offer(poll.left); 
                if(poll.right!=null) queue.offer(poll.right);
            }
            count++; // 计数
        }
        return count;
    }
```

#### 翻转二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/invert-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/InvertBinaryTree.java)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

##### 题解

递归交换每一个节点的左子树与右子树

```java
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        TreeNode left = invertTree(root.left); // 对左子树进行反转
        TreeNode right = invertTree(root.right); // 对右子树进行反转
        // 交换左右子树
        root.left = right;
        root.right = left;
        return root;
    }
```

保证每一个节点的左子树与右子树都能交换的非递归写法

```java
    public TreeNode invertTree2(TreeNode root) {
        if(root==null){
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            TreeNode poll = queue.poll();
            // 添加新的节点
            if(poll.left!=null){
                queue.offer(poll.left);
            }
            if(poll.right!=null){
                queue.offer(poll.right);
            }
            // 交换该节点的左右子树
            TreeNode temp = poll.left;
            poll.left = poll.right;
            poll.right = temp;
        }
        return root;
    }
```

#### 合并二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/merge-two-binary-trees/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MergeTwoBinaryTrees.java)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

 

**提示：**

- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-10^4 <= Node.val <= 10^4`

##### 题解

判断两棵树对应节点的情况，如果均不为空，该处的节点的值应为两节点值的和；有一方为空，应为不为空的节点；均为空则为null

判断每一处对应节点的情况后，递归合并左右子树

```java
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return null;
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        TreeNode root = new TreeNode(root1.val + root2.val); // 节点均不为空，求和
        root.left = mergeTrees(root1.left, root2.left); // 递归合并左子树
        root.right = mergeTrees(root1.right, root2.right); // 递归合并右子树
        return root; // 返回根节点
    }
```

#### 路径总和

##### 题目描述

[原题链接](https://leetcode.cn/problems/path-sum/description/)

[原题链接](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/PathSum.java)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

 

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

##### 题解

递归判断root左子树或右子树的和是否为`targetSum-root.val`

```java
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        return check(root,targetSum);
    }
    public boolean check(TreeNode root, int targetSum) {
        if(root.left==null&&root.right==null){ // 叶子节点
            return targetSum-root.val==0;
        }
        if(root.left!=null&&root.right!=null){ // 左右子树均存在
            return check(root.left,targetSum-root.val) || check(root.right,targetSum-root.val);
        } else if(root.left!=null){ // 左子树
            return check(root.left,targetSum-root.val);
        } else { //右子树
            return check(root.right,targetSum-root.val);
        }
    }
```

简写

```java
    public boolean hasPathSum2(TreeNode root, int targetSum) {
        if(root==null){ // root为null时，root不可能为叶子节点
            return false;
        }
        // 判断到达此叶子节点的路径和是否满足要求
        if(root.left==null&&root.right==null&&root.val==targetSum) return true; 
        // 递归判断左子树与右子树
        return hasPathSum2(root.left,targetSum-root.val) || hasPathSum2(root.right,targetSum-root.val);
    }
```

非递归写法（使用队列进行辅助）

```java
    public boolean hasPathSum3(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        Queue<TreeNode> nodeQueue = new LinkedList<>(); // 存储节点
        Queue<Integer> sumQueue = new LinkedList<>(); // 存储和，与节点对应
        nodeQueue.offer(root);
        sumQueue.add(root.val);
        while (!nodeQueue.isEmpty()){
            TreeNode node = nodeQueue.poll();
            int sum = sumQueue.poll();
            if(node.left==null&&node.right==null){ // 叶子节点
                if(sum==targetSum)
                    return true;
            }
            // 添加节点与其对应的路径和
            if(node.left!=null){
                nodeQueue.offer(node.left);
                sumQueue.offer(sum+node.left.val);
            }
            if(node.right!=null){
                nodeQueue.offer(node.right);
                sumQueue.offer(sum+node.right.val);
            }
        }
        return false;
    }
```

#### 对称二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/symmetric-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SymmetricTree.java)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

##### 题解

递归判断左子树与右子树节点是否对应相同

```java
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return check(root.left, root.right); // 左右子树
    }

    public boolean check(TreeNode left, TreeNode right) {
        if (left == null && right == null) return true; // 均为空
        // 对应节点不相同
        if (left == null || right == null) return false; 
        if (left.val != right.val) return false;
        // 继续进行对称判断
        return check(left.left, right.right) && check(left.right, right.left);
    }
```

非递归写法（使用队列进行辅助）

```java
    public boolean isSymmetric2(TreeNode root) {
        if (root == null) {
            return true;
        }
        Queue<TreeNode> queue = new LinkedList<>(); // 存储节点
        queue.offer(root.left);
        queue.offer(root.right);
        while (!queue.isEmpty()) {
            TreeNode left = queue.poll(); // 左子树
            TreeNode right = queue.poll(); // 右子树
            if (left == null && right == null) continue; // 均为空，继续判断
            // 对应节点不相同
            if (left == null || right == null) return false;
            if (left.val != right.val) return false;
            // 添加对应节点，先左后右
            queue.offer(left.left);
            queue.offer(right.right);
            queue.offer(left.right);
            queue.offer(right.left);
        }
        return true;
    }
```

#### 平衡二叉树

##### 题目描述

[原题链接](https://leetcode.cn/problems/balanced-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/BalancedBinaryTree.java)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```

 

**提示：**

- 树中的节点数在范围 `[0, 5000]` 内
- `-10^4 <= Node.val <= 10^4`

##### 题解

递归求解左右子树的深度进行比较，相差大于1则肯定不为高度平衡二叉树

```java
    public boolean isBalanced(TreeNode root) {
        check(root);
        return result;
    }
    boolean result = true;
    public int check(TreeNode root) {
        if(root==null){
            return 0;
        }
        int left = check(root.left)+1;
        int right = check(root.right)+1;
        if(right-left>1||left-right>1){ // 左右子树深度相差大于1
            result = false;
        }
        return Math.max(right,left);
    }
```

#### 二叉树的最小深度

##### 题目描述

[原题链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MinimumDepthOfBinaryTree.java)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

 

**提示：**

- 树中节点数的范围在 `[0, 10^5]` 内
- `-1000 <= Node.val <= 1000`

##### 题解

可以递归求解左右子树的深度，左右子树均存在，则取最小深度，有一方不存在选择存在那一方的深度（最大深度）

```java
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = minDepth(root.left);
        int right = minDepth(root.right);
        if (root.left != null && root.right != null) {
            return Math.min(left, right) + 1;
        } else {
            return Math.max(left, right) + 1;
        }
    }
```

因为是求最小深度，层次遍历要更好一些，可以及时返回

```java
    public int minDepth2(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int result = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            result++;
            while (size-- > 0) { // 遍历一层
                TreeNode node = queue.poll();
                if (node.left == null && node.right == null) { // 叶子节点
                    return result;
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return result;
    }
```

#### 左叶子之和

##### 题目描述

[原题链接](https://leetcode.cn/problems/sum-of-left-leaves/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SumOfLeftLeaves.java)

给定二叉树的根节点 `root` ，返回所有左叶子之和。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**示例 2:**

```
输入: root = [1]
输出: 0
```

 

**提示:**

- 节点数在 `[1, 1000]` 范围内
- `-1000 <= Node.val <= 1000`

##### 题解

递归求解，通过参数来判断叶子节点是否为左叶子节点

```java
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }
        check(root.left, true);
        check(root.right, false);
        return result;
    }

    int result = 0;

    public void check(TreeNode root, boolean flag) {
        if (root == null) {
            return;
        }
        if (root.left == null && root.right == null) { // 叶子节点
            if (flag) { // 左叶子节点
                result += root.val;
            }
        }
        // 继续递归判断
        if (root.left != null) {
            check(root.left, true);
        }
        if (root.right != null) {
            check(root.right, false);
        }
    }
```

#### 修剪二叉搜索树

##### 题目描述

[原题链接](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/TrimABinarySearchTree.java)

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)

```
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)

```
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
```

 

**提示：**

- 树中节点数在范围 `[1, 104]` 内
- `0 <= Node.val <= 10^4`
- 树中每个节点的值都是 **唯一** 的
- 题目数据保证输入是一棵有效的二叉搜索树
- `0 <= low <= high <= 10^4`

##### 题解

题目所给的树是一棵有效的二叉搜索树，所以对于节点 root，如果`root.val>high`，则root的右子树全部都大于high，需要删除；如果`root.val<low`，则root的左子树全部都小于low，需要删除

```java
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) {
            return null;
        }
        if (root.val > high) return trimBST(root.left, low, high); // 删除右子树
        if (root.val < low) return trimBST(root.right, low, high); // 删除左子树
        root.left = trimBST(root.left, low, high); // 递归删除左子树不符合要求的节点
        root.right = trimBST(root.right, low, high); // 递归删除右子树不符号要求的节点
        return root;
    }
```

