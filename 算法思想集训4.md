## 数据结构相关（一）

### 栈和队列

#### 用栈实现队列

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementQueueUsingStacks.java)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

 

**示例 1：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```



 

**提示：**

- `1 <= x <= 9`
- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）

##### 题解

使用两个栈，一个用作输出，一个用作输入，当输出栈为空时需要将输入栈的数据转存到输出栈

```java
class MyQueue {
    Stack<Integer> in;// 输入栈
    Stack<Integer> out;// 输出栈

    public MyQueue() {
        in = new Stack<>();
        out = new Stack<>();
    }

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        transform();
        return out.pop();
    }

    public int peek() {
        transform();
        return out.peek();
    }

    public boolean empty() {
        return in.empty() && out.isEmpty();
    }

    private void transform() {
        if (out.isEmpty()) {// 输出栈为空
            while (!in.isEmpty()) {// 将输入栈的数据转存到输出栈
                out.push(in.pop());
            }
        }
    }

}
```

#### 用队列实现栈

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-stack-using-queues/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementStackUsingQueues.java)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

 

**注意：**

- 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

 

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

 

**提示：**

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

 

##### 题解

可以使用一个队列来完成，添加元素后将之前的元素进行反转添加到队列末尾

```java
class MyStack {
    Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.add(x);
        for (int i = 1; i < queue.size(); i++) { // 将之前的元素进行反转
            queue.add(queue.remove());
        }
    }

    public int pop() {
        return queue.isEmpty() ? -1 : queue.poll();
    }

    public int top() {
        return queue.isEmpty() ? -1 : queue.peek();

    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

#### 最小栈

##### 题目描述

[原题链接](https://leetcode.cn/problems/min-stack/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MinStack.java)

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

 

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

 

**提示：**

- `-2^31 <= val <= 2^31 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 10^4` 次

##### 题解

使用两个栈，一个用来存储数据，另一个用来存储对应最小值

```java
class MinStack2 {
    Stack<Integer> input;
    Stack<Integer> min;
    public MinStack2() {
        input = new Stack<>();
        min = new Stack<>();
    }

    public void push(int val) {
        input.push(val);
        if(min.isEmpty()){
            min.push(val);
        } else {
            min.push(Math.min(min.peek(),val));// 存储对应最小值
        }
    }

    public void pop() {
        if(!input.isEmpty()){
            input.pop();
            min.pop();
        }
    }

    public int top() {
        return input.isEmpty()?-1:input.peek();
    }

    public int getMin() {
        return min.isEmpty()?-1:min.peek();
    }
}
```

#### 队列的最大值

##### 题目描述

[原题链接](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MaximumValueOfQueue.java)

请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的**均摊**时间复杂度都是O(1)。

若队列为空，`pop_front` 和 `max_value` 需要返回 -1

**示例 1：**

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

**示例 2：**

```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

 

**限制：**

- `1 <= push_back,pop_front,max_value的总操作数 <= 10000`
- `1 <= value <= 10^5`

##### 题解

使用普通队列来存储数据，使用双端队列来存储最大值。队列遵循后进后出，后面添加的元素存在的时间要长一些，如果后面添加的元素比前面的最大元素大，则应覆盖前面的最大值。出队时，若出队元素等于双端队列的队头元素则应同时出队

```java
class MaxQueue {
    Queue<Integer> queue;
    Deque<Integer> maxDeque;
    public MaxQueue() {
        queue = new LinkedList<>();
        maxDeque = new LinkedList<>();
    }

    public int max_value() {
        if(maxDeque.isEmpty()){
            return -1;
        }
        return maxDeque.peekFirst();
    }

    public void push_back(int value) {
        while (!maxDeque.isEmpty()&&maxDeque.peekLast()<value){ // 覆盖前面的最大值
            maxDeque.pollLast();
        }
        queue.add(value);
        maxDeque.addLast(value);
    }

    public int pop_front() {
        if(queue.isEmpty()){
            return -1;
        }
        Integer poll = queue.poll();
        if(poll.equals(maxDeque.peekFirst())){ // 出队元素恰好为双端队列队头，同时出队
            maxDeque.pollFirst();
        }
        return poll;
    }
}
```

#### 有效的括号

##### 题目描述

[原题链接](https://leetcode.cn/problems/valid-parentheses/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ValidParentheses.java)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

 

**提示：**

- `1 <= s.length <= 10^4`
- `s` 仅由括号 `'()[]{}'` 组成

##### 题解

遍历字符串，当遇到`]`，前面必须有`[`，字符串才有效，`[`不一定紧挨着`]`，中间可能隔着其它符号

可以使用栈来存储左括号，当遍历到的字符为右括号时，判断弹出的栈顶元素是否能匹配，不匹配则字符串无效。若字符串符号有效，遍历结束后，栈应为空

```java
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i <s.length() ; i++) {
            char c = s.charAt(i);
            if(c=='('||c=='['||c=='{'){ // 左括号入栈
                stack.push(c);
            } else { // 判断右括号是否与栈顶元素匹配
                if(stack.isEmpty()){
                    return false;
                }
                Character pop = stack.pop();
                if((c==')'&&pop!='(')||(c==']'&&pop!='[')||(c=='}'&&pop!='{')){
                    return false;
                }
            }
        }
        return stack.isEmpty(); // 最终栈应为空
    }
```

#### 每日温度

##### 题目描述

[原题链接](https://leetcode.cn/problems/daily-temperatures/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/DailyTemperatures.java)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 10^5`
- `30 <= temperatures[i] <= 100`

##### 题解

在遍历数组时用 栈 把数组的下标存起来，如果当前遍历的数比栈顶元素对应的数据大，说明栈顶元素的下一个比它大的数就是当前元素。

```java
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            while (!stack.isEmpty()&&temperatures[i]>temperatures[stack.peek()]){ // 当前元素比栈顶元素对应的数据大
                Integer pop = stack.pop();
                result[pop] = i-pop; // 记录位置
            }
            stack.push(i); // 入栈
        }
        return result;
    }
```

#### 下一个更大元素 I

##### 题目描述

[原题链接](https://leetcode.cn/problems/next-greater-element-i/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/NextGreaterElementI.java)

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

 

**示例 1：**

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

**示例 2：**

```
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
```

 

**提示：**

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 10^4`
- `nums1`和`nums2`中所有整数 **互不相同**
- `nums1` 中的所有整数同样出现在 `nums2` 中

##### 题解

对于每个 `0 <= i < nums1.length` ，需要先找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，然后在 `nums2` 中确定 `nums2[j]` 的 下一个更大元素。所以可以先找出`nums2`中有下一个最大元素的元素并形成映射关系，可以用栈来辅助寻找下一个最大元素

```java
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> map = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        for (int num : nums2) {
            while (!stack.isEmpty() && num > stack.peek()) { //当前元素大于栈顶元素
                map.put(stack.pop(), num); // 当前元素即为栈顶元素的下一个最大元素
            }
            stack.push(num);
        }
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i]= map.getOrDefault(nums1[i], -1); // 根据映射关系保存结果
        }
        return result;
    }
```

#### 下一个更大元素 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/next-greater-element-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/NextGreaterElementII.java)

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

 

**示例 1:**

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

**示例 2:**

```
输入: nums = [1,2,3,4,3]
输出: [2,3,4,-1,4]
```

 

**提示:**

- `1 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`

##### 题解

同样可以使用栈辅助找到下一个最大的数，由于是循环数组所以需要遍历两次

```java
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[nums.length];
        Arrays.fill(result, -1);
        for (int i = 0; i < nums.length; i++) { // 一次遍历
            while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
                result[stack.pop()] = nums[i];
            }
            stack.push(i);
        }
        for (int num : nums) { // 二次遍历
            while (result[stack.peek()] == -1 && num > nums[stack.peek()]) {
                result[stack.pop()] = num;
            }
        }
        return result;
    }
```

### 哈希表

利用 Hash Table 可以快速查找一个元素是否存在等问题，但是需要一定的空间来存储。在优先考虑 时间复杂度的情况下，可以利用 Hash Table 这种空间换取时间的做法。

#### 两数之和

##### 题目描述

[原题链接](https://leetcode.cn/problems/two-sum/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/TwoSum.java)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **只会存在一个有效答案**

##### 题解 

用 `HashMap` 存储数组元素和索引的映射，在访问到 `nums[i]` 时，判断 `HashMap` 中是否存在 `target - nums[i]` ，如果存在说明` target - nums[i]` 所在的索引和 i 就是要找的两个数。

```java
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target-nums[i])) {
                return new int[]{map.get(target-nums[i]),i};
            } else {
                map.put(nums[i],i);
            }
        }
        return null;
    }
```

也可以在此基础上使用双指针进一步降低时间复杂度（如果想要排序后通过双指针或者二分查找来解题，需要提前记录元素对应位置）

```java
    public int[] twoSum2(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        int left = 0,right = nums.length-1;
        while (left<=right){
            int l = target-nums[left];
            int r = target-nums[right];
            if(map.containsKey(l)){
                return new int[]{map.get(l),left};
            } else {
                map.put(nums[left],left++);
            }

            if(map.containsKey(r)){
                return new int[]{map.get(r),right};
            } else {
                map.put(nums[right],right--);
            }
        }
        return null;
    }
```

#### 最长和谐子序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-harmonious-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/LongestHarmoniousSubsequence.java)

和谐数组是指一个数组里元素的最大值和最小值之间的差别 **正好是 `1`** 。

现在，给你一个整数数组 `nums` ，请你在所有可能的子序列中找到最长的和谐子序列的长度。

数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。

 

**示例 1：**

```
输入：nums = [1,3,2,2,5,2,3,7]
输出：5
解释：最长的和谐子序列是 [3,2,2,2,3]
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：2
```

**示例 3：**

```
输入：nums = [1,1,1,1]
输出：0
```

 

**提示：**

- `1 <= nums.length <= 2 * 10^4`
- `-10^9 <= nums[i] <= 10^9`

##### 题解

使用`HashMap` 来存储元素与个数，遍历数组，判断哈希表中是否有相差为1的值（大于或者小于）

```java

    public int findLHS(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>();
        int max = 0;
        for (int num : nums) {
            int count = map.getOrDefault(num, 0); // 获取元素个数
            if(map.containsKey(num-1)){
                max = Math.max(count+1+map.get(num-1),max);
            }
            if(map.containsKey(num+1)){
                max = Math.max(count+1+map.get(num+1),max);
            }
            map.put(num,count+1); // 更新元素个数
        }
        return max;
    }
```

### 字符串

#### 有效的字母异位词

##### 题目描述

[原题链接](https://leetcode.cn/problems/valid-anagram/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ValidAnagram.java)

给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。

**注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。

 

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

 

**提示:**

- `1 <= s.length, t.length <= 5 * 10^4`
- `s` 和 `t` 仅包含小写字母

 

##### 题解

字符串只包含小写字符，总共有 26 个小写字符。可以用数组来记录字符出现的次数，s中出现的字符为其加1，t中出现的字符为其减1，最终判断数组是否全为0

```java
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        int[] count = new int[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        for (int num : count) {
            if (num != 0) {
                return false;
            }
        }
        return true;
    }
```

#### 同构字符串

##### 题目描述

[原题链接](https://leetcode.cn/problems/isomorphic-strings/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/IsomorphicStrings.java)

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

 

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**示例 2：**

```
输入：s = "foo", t = "bar"
输出：false
```

**示例 3：**

```
输入：s = "paper", t = "title"
输出：true
```

 

**提示：**



- `1 <= s.length <= 5 * 10^4`
- `t.length == s.length`
- `s` 和 `t` 由任意有效的 ASCII 字符组成

##### 题解

可以使用哈希表来存储映射关系进行判断

```java
    public boolean isIsomorphic(String s, String t) {
        if(s.length()!=t.length()) return false;
        Map<Character,Character> map = new HashMap<>(256);
        for (int i = 0; i < s.length() ; i++) {
            char c = s.charAt(i);
            if(map.containsKey(c)){ // 已存储映射关系
                if(map.get(c)!=t.charAt(i)) return false; // 不符合映射关系
            } else {
                if(map.containsValue(t.charAt(i))){ // 不同字符不能映射到同一个字符上
                    return false;
                }
                map.put(c,t.charAt(i)); // 添加映射
            }
        }
        return true;
    }
```

也可以使用数组记录一个字符上次出现的位置，如果两个字符串中某个字符上次出现的位置一样，那么就属于同构

```java
    public boolean isIsomorphic2(String s, String t) {
        if(s.length()!=t.length()) return false;
        int[] sc = new int[256];
        int[] tc = new int[256];
        for (int i = 0; i < s.length() ; i++) {
            if(sc[s.charAt(i)]!=tc[t.charAt(i)]) return false;
            sc[s.charAt(i)] = i+1;
            tc[t.charAt(i)] = i+1;
        }
        return true;
    }
```

#### 最长回文串

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-palindrome/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/LongestPalindrome.java)

给定一个包含大写字母和小写字母的字符串 `s` ，返回 *通过这些字母构造成的 **最长的回文串*** 。

在构造过程中，请注意 **区分大小写** 。比如 `"Aa"` 不能当做一个回文字符串。

 

**示例 1:**

```
输入:s = "abccccdd"
输出:7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

**示例 2:**

```
输入:s = "a"
输出:1
```

**示例 3：**

```
输入:s = "aaaaaccc"
输出:7
```

 

**提示:**

- `1 <= s.length <= 2000`
- `s` 只由小写 **和/或** 大写英文字母组成

##### 题解

使用长度为 128 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。

```java
    public int longestPalindrome(String s) {
        int[] count = new int[128];
        for (int i = 0; i <s.length() ; i++) {
            count[s.charAt(i)]++;
        }
        int sum = 0;
        for (int num : count) {
            sum+=num/2*2; // 取最大偶数
        }
        return sum<s.length()?sum+1:sum; // 中间可能有单独字符
    }
```

####  回文数

##### 题目描述

[原题链接](https://leetcode.cn/problems/palindrome-number/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/PalindromeNumber.java)

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

 

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

 

**提示：**

- `-2^31 <= x <= 2^31 - 1`

##### 题解

将 x 进行倒序比较

```java
    public boolean isPalindrome(int x) {
        if(x==0) return true;
        if(x<0||x%10==0) return false; // x以0结尾倒序首位为0
        int reverse = 0;
        int temp = x;
        while (temp!=0){ 
            reverse = reverse*10+temp%10;
            temp/=10;
        }
        return x==reverse;
    }
```

仿照回文串将x的后半部分进行倒序与前半部分进行比较

```java
    public boolean isPalindrome2(int x) {
        if(x==0) return true;
        if(x<0||x%10==0) return false;

        int reverse = 0;
        while (x>reverse){ // 倒序一半
            reverse = reverse*10+x%10;
            x/=10;
        }
        return x==reverse||x==reverse/10; // x为奇数时中间一位可以忽略
    }
```

#### 回文子串

##### 题目描述

[原题链接](https://leetcode.cn/problems/palindromic-substrings/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/PalindromicSubstrings.java)

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成

##### 题解

从字符串的某一位开始，尝试着去扩展子字符串。对于已经确定的回文串在其左右添加相同的字符仍然构成一个回文串

```java

    int result = 0;
    public int countSubstrings(String s) {
        for (int i = 0; i < s.length(); i++) {
            statistics(s,i,i); // 奇数个字符构成的回文串
            statistics(s,i-1,i); // 偶数个字符构成的回文串
        }
        return result;
    }

    private void statistics(String s, int left, int right) {
        while (left>=0&&right<s.length()&&s.charAt(left)==s.charAt(right)){ // 尝试扩展
            left--;
            right++;
            result++;
        }
    }
```

#### 计数二进制子串

##### 题目描述

[原题链接](https://leetcode.cn/problems/count-binary-substrings/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/CountBinarySubstrings.java)

给定一个字符串 `s`，统计并返回具有相同数量 `0` 和 `1` 的非空（连续）子字符串的数量，并且这些子字符串中的所有 `0` 和所有 `1` 都是成组连续的。

重复出现（不同位置）的子串也要统计它们出现的次数。

 

**示例 1：**

```
输入：s = "00110011"
输出：6
解释：6 个子串满足具有相同数量的连续 1 和 0 ："0011"、"01"、"1100"、"10"、"0011" 和 "01" 。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。
```

**示例 2：**

```
输入：s = "10101"
输出：4
解释：有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。
```

 

**提示：**

- `1 <= s.length <= 10^5`
- `s[i]` 为 `'0'` 或 `'1'`

##### 题解

根据0，1对字符串进行分组，统计每一组0或1的个数，例如`00110011`可以分组为`[2,2,2,2]`，相邻两组均不相同。2个0与2个1可以组成两个符合要求的子串，2个0与4个1同样可以组成两个符合要求的子串，两者取其小。

所以可以从前往后遍历字符串，统计在一起的0或1的个数，出现相邻两组时即可计算符合要求的子串数量

```java
    public int countBinarySubstrings(String s) {
        int index = 0; // 遍历的下标索引
        int result = 0; // 结果
        int temp = 0; // 前面一组的字符数量
        int count; // 当前一组的字符数量
        while (index<s.length()){
            count = 0;
            char c = s.charAt(index);
            while (index<s.length()&&s.charAt(index)==c){ // 统计当前一组字符数量
                count++;
                index++;
            }
            result+=Math.min(count,temp); // 两组取其小
            temp = count; // 更新上一组数量
        }
        return result;
    }
```

### 数组与矩阵

#### 移动零

##### 题目描述

[原题链接](https://leetcode.cn/problems/move-zeroes/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MoveZeroes.java)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

 

**提示**:

- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

##### 题解

寻找数组中的非0数字，从前往后依次进行填充，最后在数组末尾填充0

```java
    public void moveZeroes(int[] nums) {
        int index = 0;
        for (int num : nums) { // 遍历数组
            if(num!=-0) nums[index++] = num; // 按顺序填充非0数字
        }
        while (index<nums.length){ // 尾部填充0
            nums[index++] = 0;
        }
    }
```

#### 错误的集合

##### 题目描述

[原题链接](https://leetcode.cn/problems/set-mismatch/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SetMismatch.java)

集合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

 

**示例 1：**

```
输入：nums = [1,2,2,4]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[1,2]
```

 

**提示：**

- `2 <= nums.length <= 10^4`
- `1 <= nums[i] <= 10^4`

##### 题解

可以通过交换数组元素，使得数组上的元素在正确的位置上，即`nums[i] = i+1`，当`nums[i] != i+1`时，我们虽然不确定i+1是否存在，但可以确定`nums[i]`对应的位置应为`nums[i]-1`，那么就交换第 i 位 和 `nums[i] - 1` 位上的元素，使得`nums[nums[i] - 1] = nums[i] `

交换操作需要循环进行，因为一次交换没办法使得第 i 位上的元素是正确的。但是要交换的两个元素可能就是重复元素，那么循环就可能永远进行 下去，终止循环的方法是加上 `nums[i] != nums[nums[i] - 1]` 条件。

```java
    public int[] findErrorNums(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) { // 交换元素
                swap(nums, i, nums[i] - 1);
            }
        }
        for (int i = 0; i < nums.length; i++) { // 寻找错误的位置
            if (nums[i] != i + 1) {
                return new int[]{nums[i], i + 1};
            }
        }
        return null;
    }

    // 交换
    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
```

#### 找到所有数组中消失的数字

##### 题目描述

[原题链接](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/FindAllNumbersDisappearedInAnArray.java)

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

 

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[2]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 10^5`
- `1 <= nums[i] <= n`

##### 题解

将数字与数组下标形成映射关系，即`nums[i] = i+1`，当`nums[i] != i+1`时，我们虽然不确定i+1是否存在，但可以确定`nums[i]`对应的位置应为`nums[i]-1`，那么就交换第 i 位 和 `nums[i] - 1` 位上的元素，使得`nums[nums[i] - 1] = nums[i] `

交换操作需要循环进行，因为一次交换没办法使得第 i 位上的元素是正确的。但是要交换的两个元素可能就是重复元素，那么循环就可能永远进行 下去，终止循环的方法是加上 `nums[i] != nums[nums[i] - 1]` 条件。

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) { // 循环交换
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }

        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) { // 查询结果
            if (nums[i] != i + 1) {
                list.add(i+1);
            }
        }
        return list;
    }
```

#### 数组中重复的数据

##### 题目描述

[原题链接](https://leetcode.cn/problems/find-all-duplicates-in-an-array/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/FindAllDuplicatesInAnArray.java)

给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **一次** 或 **两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。

你必须设计并实现一个时间复杂度为 `O(n)` 且仅使用常量额外空间的算法解决此问题。

 

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1,2]
输出：[1]
```

**示例 3：**

```
输入：nums = [1]
输出：[]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 10^5`
- `1 <= nums[i] <= n`
- `nums` 中的每个元素出现 **一次** 或 **两次**

##### 题解

与前面两题的思路相同，都是通过交换元素形成映射关系，最终去寻找特例，即没有形成映射关系的元素

```java
    public List<Integer> findDuplicates(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i]!=i+1&&nums[i]!=nums[nums[i]-1]){ // 交换元素
                int temp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = temp;
            }
        }

        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) { // 查询结果
            if(nums[i]!=i+1){
                list.add(nums[i]);
            }
        }
        return list;
    }
```

#### 寻找重复数

##### 题目描述

[原题链接](https://leetcode.cn/problems/find-the-duplicate-number/description/)

[原题链接](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/FindTheDuplicateNumber.java)

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

 

**提示：**

- `1 <= n <= 10^5`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

##### 题解

虽然数组是无序的，但是可以利用数字的有序进行二分查找，根据查找结果调整数字。

```java
    public int findDuplicate2(int[] nums) {
        int left = 1,right = nums.length-1; // left与right是需要寻找的数字，不是数组下标
        while (left<=right){
            int mid = left+(right-left)/2;
            int count = 0;
            for (int num : nums) { // 统计不大于目标数字的元素个数
                if(num<=mid) count++;
            }
            if(count>mid) // 个数大于目标数字说明重复数字不大于目标数字
                right = mid - 1; // 数字减小 
            else // 重复数字比目标数字大 
                left = mid + 1; // 数字增大
        }
        return left;
    }
```

因为`1 <= nums[i] <= n`，数组下标与数组元素可以形成映射关系，即存在`nums[nums[i]]`，可以利用这个关系使数组在逻辑上形成一个链表，存在重复元素即链表有环，寻找重复元素即可转换为寻找环的起点

寻找环的起点可以利用快慢指针（龟兔赛跑）来解决，快慢指针相遇必定在环内，相遇后将快指针移动到起点，快慢指针以相同的速度前进，再次相遇即为环的起点

> 设乌龟走过的全部路程为i，m是表头和环的起点之间的距离，n是环的起点和相遇点之间的距离，L为环的长度
>
> 那么有
>
> **i = m + n + aL** **（1）**「a是乌龟绕过的环的圈数」
>
> 因为兔子的速度是乌龟的两倍，所以有
>
> **2i = m + n + bL（2）**「b是兔子绕过的环的圈数」
>
> **(2) - (1)**可得：
>
> **i = (b - a)L （3）**
>
> 结合式子(1)、(3)可得 m + n + aL = (b - a)L，所以有
>
> **m + n = (b-2a)L（4）**{因为m+n>0且L>0, 所以b-2a>=1}
>
> **所以可以得出结论：**
>
> **m + n = 环长度L的正整数倍。（5）**
>
> **当乌龟和兔子第一次相遇后，让乌龟回到起点，兔子仍在相遇点，乌龟以每次1步的速度向前走，兔子以相同的速度绕环前进**。当走了m步时，兔子和乌龟正好都在环的起点。因为兔子相对于起点走了(n+m)步，由结论(5)可知此时的相遇点必然是环的起点。

```java
    public int findDuplicate(int[] nums) {
        int slow = nums[0],fast = nums[nums[0]]; 
        while (slow!=fast){ // 快慢指针第一次相遇
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        fast = 0; // 移动到起点
        while (slow!=fast){ // 速度相同再次相遇即为环的起点
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
```

#### 搜索二维矩阵 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SearchAMatrixII.java)

编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

 

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= n, m <= 300`
- `-10^9 <= matrix[i][j] <= 10^9`
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- `-10^9 <= target <= 10^9`

##### 题解

数组的元素排序是有一定顺序的，可以发现从右上角进行搜索可以很好利用这一点（类似于二分搜索），对于右上角的元素，如果目标值大于该值，就向下搜索（右边已经搜索过了），如果目标值小于该值，就向左搜索（上边已经搜索过了）

```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int m = matrix.length, n = matrix[0].length;
        int row = 0, col = n - 1;
        while (row < m && col >= 0) {
            if (matrix[row][col] == target) {
                return true;
            } else if (matrix[row][col] < target) {
                row++; // 向下搜索
            } else {
                col--; // 向左搜索
            }
        }
        return false;
    }
```

#### 有序矩阵中第 K 小的元素

##### 题目描述

[原题链接](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/KthSmallestElementInASortedMatrix.java)

给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。
请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。

你必须找到一个内存复杂度优于 `O(n2)` 的解决方案。

 

**示例 1：**

```
输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
```

**示例 2：**

```
输入：matrix = [[-5]], k = 1
输出：-5
```

 

**提示：**

- `n == matrix.length`
- `n == matrix[i].length`
- `1 <= n <= 300`
- `-10^9 <= matrix[i][j] <= 10^9`
- 题目数据 **保证** `matrix` 中的所有行和列都按 **非递减顺序** 排列
- `1 <= k <= n2`

##### 题解

因为数组是有序的，所以可以利用二分查找进行搜索。可以发现左上角是数组最小值，右上角是数组最大值，取这两个值作为搜索的初始边界，需要寻找的元素一定在这个范围内。每次搜索取中间值 mid 后，需要遍历数组确定比 mid 小的元素个数，当个数为k时，需要进一步寻找数组中第一个大于等于mid的元素（mid不一定是数组元素），即为我们所寻找的元素。

```java
    public int kthSmallest(int[][] matrix, int k) {
        int m = matrix.length,n = matrix[0].length;
        int left = matrix[0][0],right = matrix[m-1][n-1];
        while (left<=right){
            int mid = left + (right-left)/2;
            int count = 0;
            for (int[] ints : matrix) { // 统计个数
                for (int j = 0; j < n && ints[j] <= mid; j++) {
                    count++;
                }
            }
            if(count<k) left = mid +1; 
            else right = mid-1; // 不断靠拢直到左右指针均指向目标元素
        }
        return left;
    }
```

也可以利用小顶堆来辅助进行求解，先将第一行的元素放入堆中，每次取出最小值，再加入这个最小值对应的下一位元素，只要取出k-1个最小值，堆顶就是第k个最小值

```java
    public int kthSmallest2(int[][] matrix, int k) {
        int m = matrix.length, n = matrix[0].length;
        PriorityQueue<Tuple> priorityQueue = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            priorityQueue.offer(new Tuple(0, i, matrix[0][i]));
        }
        for (int i = 0; i < k - 1; i++) { // 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数

            Tuple tuple = priorityQueue.poll(); 
            assert tuple != null;
            if (tuple.x == m - 1) continue;
            priorityQueue.offer(new Tuple(tuple.x + 1, tuple.y, matrix[tuple.x + 1][tuple.y]));
        }
        return Objects.requireNonNull(priorityQueue.poll()).val;
    }

    class Tuple implements Comparable<Tuple> {
        int x, y, val;

        public Tuple(int x, int y, int val) {
            this.x = x;
            this.y = y;
            this.val = val;
        }

        @Override
        public int compareTo(Tuple that) {
            return this.val - that.val;
        }
    }
```

### 链表

#### 相交链表

##### 题目描述

[原题链接](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/IntersectionOfTwoLinkedLists.java)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

 

**示例 2：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

 

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 10^4`
- `1 <= Node.val <= 10^5`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

 

##### 题解

两个链表的头指针与相交节点的距离不同会导致遍历时出现差异，为了解决这个不同可以提前遍历两个链表记录长度，让头指针与相交节点的距离比较长的链表先遍历一部分然后再同步遍历。

还有一种做法就是当一个链表遍历完时，链接到另一个链表的表头继续遍历，另一个链表也做同样的处理直到遍历的节点相同或为空

```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pA = headA, pB = headB;
        while (pA != null && pB != null) {
            if (pA == pB) {
                return pA;
            }
            pA = pA.next;
            pB = pB.next;
            if (pA == null && pB != null) {
                pA = headB;
            }
            if (pB == null && pA != null) {
                pB = headA;
            }
        }
        return null;
    }
```

还有一种写法看上去体面一些

```java
    public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
```

#### 反转链表

##### 题目描述

[原题链接](https://leetcode.cn/problems/reverse-linked-list/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ReverseLinkedList.java)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

 

**提示：**

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

 

##### 题解

头插法能够按逆序构建链表

```java
    public ListNode reverseList(ListNode head) {
        if(head==null) return null;
        ListNode p = head; // 头节点
        head = head.next;
        p.next = null;
        while (head!=null){ // 反转链表
            ListNode q = head;
            head = head.next;
            q.next = p;
            p = q;
        }
        return p;
    }
```

递归写法

```java
    public ListNode reverseList2(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }
        ListNode newHead = reverseList2(head.next); // 最后一个节点为头节点
        // 反转链表
        head.next.next = head;
        head.next = null; // 最后一个节点的后继结点需要为空
        return newHead; // 返回头节点
    }
```

#### 合并两个有序链表

##### 题目描述

[原题链接](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MergeTwoSortedLists.java)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

##### 题解

根据顺序依次链接节点，如果有一个链表的所有节点都链接完，直接将另一个链表的剩余节点链接到新链表的末尾

```java
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode head = new ListNode(0);
        ListNode p = head;
        while (list1 != null || list2 != null) {
            if (list1 == null) {
                head.next = list2;
                break;
            }
            if (list2 == null) {
                head.next = list1;
                break;
            }
            if (list1.val > list2.val) {
                head.next = list2;
                head = head.next;
                list2 = list2.next;
            } else {
                head.next = list1;
                head = head.next;
                list1 = list1.next;
            }
        }
        return p.next;
    }
```

递归方式

```java
    public ListNode mergeTwoLists2(ListNode list1, ListNode list2) {
        if(list1==null){
            return list2;
        } else if(list2==null){
            return list1;
        } else if(list1.val<list2.val){
            list1.next = mergeTwoLists2(list1.next,list2);
            return list1;
        } else {
            list2.next = mergeTwoLists2(list2.next,list1);
            return list2;
        }
    }
```

#### 删除排序链表中的重复元素

##### 题目描述

[原题链接](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/RemoveDuplicatesFromSortedList.java)

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)

```
输入：head = [1,1,2]
输出：[1,2]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)

```
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

 

**提示：**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**

##### 题解

在链表中改变指针即可完成删除元素

```java
    public ListNode deleteDuplicates(ListNode head) {
        ListNode p = head;
        while (p != null && p.next != null) {
            if (p.val == p.next.val) {
                ListNode q = p.next;
                p.next = p.next.next;
                q.next =  null;
            } else {
                p = p.next;

            }
        }
        return head;
    }
```

递归写法

```java
    public ListNode deleteDuplicates2(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        head.next = deleteDuplicates2(head.next);
        return head.next != null && head.val == head.next.val ? head.next : head;
    }
```

####  回文链表

##### 题目描述

[原题链接](https://leetcode.cn/problems/palindrome-linked-list/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/PalindromeLinkedList.java)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

 

**提示：**

- 链表中节点数目在范围`[1, 105]` 内
- `0 <= Node.val <= 9`

##### 题解

由于单向链表不能从后往前遍历，不引入O(n)空间的前提下需要将后半部分的链表反转后再进行比较

```java
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head,slow = head;
        while (fast!=null&&fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }
        if(fast!=null){//奇数节点
            slow = slow.next;
        }
        // 切断链表
        ListNode root = head;
        while (root.next!=slow) {
            root = root.next;
        }
        root.next = null;

        // 反转后半段链表
        root = slow;
        ListNode newHead = null;
        while (root!=null){
            fast = root.next; // fast指针充当临时变量
            root.next = newHead;
            newHead = root;
            root = fast;
        }
        // 比较，以反转后的链表长度为准，避免奇数位的影响
        // 保留两个链表的头指针，方便恢复原链表
        fast = head;
        slow = newHead;
        while (slow!=null){
            if(slow.val!=fast.val){
                return false;
            }
            slow = slow.next;
            fast = fast.next;
        }
        return true;   
    }
```

#### 奇偶链表

##### 题目描述

[原题链接](https://leetcode.cn/problems/odd-even-linked-list/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/OddEvenLinkedList.java)

给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。

**第一个**节点的索引被认为是 **奇数** ， **第二个**节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg)

```
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg)

```
输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
```

 

**提示:**

- `n == ` 链表中的节点数
- `0 <= n <= 10^4`
- `-10^6 <= Node.val <= 10^6`

##### 题解

可以将链表拆分成奇偶链表进行连接最后再拼接

```java
    public ListNode oddEvenList(ListNode head) {
        if (head == null) return head;
        ListNode root = head.next; // 偶链表头指针
        ListNode odd = head, even = head.next;
        while (odd.next != null && even.next != null) {
            odd.next = even.next; // 拼接奇数节点
            odd = odd.next;
            even.next = odd.next; // 拼接偶数节点
            even = even.next;
        }
        odd.next = root; // 将偶链表链接到奇链表末尾
        return head;
    }
```

