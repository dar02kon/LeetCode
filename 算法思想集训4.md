## 数据结构相关

### 栈和队列

#### 用栈实现队列

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementQueueUsingStacks.java)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

 

**示例 1：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```



 

**提示：**

- `1 <= x <= 9`
- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）

##### 题解

使用两个栈，一个用作输出，一个用作输入，当输出栈为空时需要将输入栈的数据转存到输出栈

```java
class MyQueue {
    Stack<Integer> in;// 输入栈
    Stack<Integer> out;// 输出栈

    public MyQueue() {
        in = new Stack<>();
        out = new Stack<>();
    }

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        transform();
        return out.pop();
    }

    public int peek() {
        transform();
        return out.peek();
    }

    public boolean empty() {
        return in.empty() && out.isEmpty();
    }

    private void transform() {
        if (out.isEmpty()) {// 输出栈为空
            while (!in.isEmpty()) {// 将输入栈的数据转存到输出栈
                out.push(in.pop());
            }
        }
    }

}
```

#### 用队列实现栈

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-stack-using-queues/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementStackUsingQueues.java)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

 

**注意：**

- 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

 

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

 

**提示：**

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

 

##### 题解

可以使用一个队列来完成，添加元素后将之前的元素进行反转添加到队列末尾

```java
class MyStack {
    Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.add(x);
        for (int i = 1; i < queue.size(); i++) { // 将之前的元素进行反转
            queue.add(queue.remove());
        }
    }

    public int pop() {
        return queue.isEmpty() ? -1 : queue.poll();
    }

    public int top() {
        return queue.isEmpty() ? -1 : queue.peek();

    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

#### 最小栈

##### 题目描述

[原题链接](https://leetcode.cn/problems/min-stack/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MinStack.java)

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

 

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

 

**提示：**

- `-2^31 <= val <= 2^31 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 10^4` 次

##### 题解

使用两个栈，一个用来存储数据，另一个用来存储对应最小值

```java
class MinStack2 {
    Stack<Integer> input;
    Stack<Integer> min;
    public MinStack2() {
        input = new Stack<>();
        min = new Stack<>();
    }

    public void push(int val) {
        input.push(val);
        if(min.isEmpty()){
            min.push(val);
        } else {
            min.push(Math.min(min.peek(),val));// 存储对应最小值
        }
    }

    public void pop() {
        if(!input.isEmpty()){
            input.pop();
            min.pop();
        }
    }

    public int top() {
        return input.isEmpty()?-1:input.peek();
    }

    public int getMin() {
        return min.isEmpty()?-1:min.peek();
    }
}
```

#### 队列的最大值

##### 题目描述

[原题链接](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MaximumValueOfQueue.java)

请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的**均摊**时间复杂度都是O(1)。

若队列为空，`pop_front` 和 `max_value` 需要返回 -1

**示例 1：**

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

**示例 2：**

```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

 

**限制：**

- `1 <= push_back,pop_front,max_value的总操作数 <= 10000`
- `1 <= value <= 10^5`

##### 题解

使用普通队列来存储数据，使用双端队列来存储最大值。队列遵循后进后出，后面添加的元素存在的时间要长一些，如果后面添加的元素比前面的最大元素大，则应覆盖前面的最大值。出队时，若出队元素等于双端队列的队头元素则应同时出队

```java
class MaxQueue {
    Queue<Integer> queue;
    Deque<Integer> maxDeque;
    public MaxQueue() {
        queue = new LinkedList<>();
        maxDeque = new LinkedList<>();
    }

    public int max_value() {
        if(maxDeque.isEmpty()){
            return -1;
        }
        return maxDeque.peekFirst();
    }

    public void push_back(int value) {
        while (!maxDeque.isEmpty()&&maxDeque.peekLast()<value){ // 覆盖前面的最大值
            maxDeque.pollLast();
        }
        queue.add(value);
        maxDeque.addLast(value);
    }

    public int pop_front() {
        if(queue.isEmpty()){
            return -1;
        }
        Integer poll = queue.poll();
        if(poll.equals(maxDeque.peekFirst())){ // 出队元素恰好为双端队列队头，同时出队
            maxDeque.pollFirst();
        }
        return poll;
    }
}
```

#### 有效的括号

##### 题目描述

[原题链接](https://leetcode.cn/problems/valid-parentheses/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ValidParentheses.java)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

 

**提示：**

- `1 <= s.length <= 10^4`
- `s` 仅由括号 `'()[]{}'` 组成

##### 题解

遍历字符串，当遇到`]`，前面必须有`[`，字符串才有效，`[`不一定紧挨着`]`，中间可能隔着其它符号

可以使用栈来存储左括号，当遍历到的字符为右括号时，判断弹出的栈顶元素是否能匹配，不匹配则字符串无效。若字符串符号有效，遍历结束后，栈应为空

```java
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i <s.length() ; i++) {
            char c = s.charAt(i);
            if(c=='('||c=='['||c=='{'){ // 左括号入栈
                stack.push(c);
            } else { // 判断右括号是否与栈顶元素匹配
                if(stack.isEmpty()){
                    return false;
                }
                Character pop = stack.pop();
                if((c==')'&&pop!='(')||(c==']'&&pop!='[')||(c=='}'&&pop!='{')){
                    return false;
                }
            }
        }
        return stack.isEmpty(); // 最终栈应为空
    }
```

#### 每日温度

##### 题目描述

[原题链接](https://leetcode.cn/problems/daily-temperatures/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/DailyTemperatures.java)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 10^5`
- `30 <= temperatures[i] <= 100`

##### 题解

在遍历数组时用 栈 把数组的下标存起来，如果当前遍历的数比栈顶元素对应的数据大，说明栈顶元素的下一个比它大的数就是当前元素。

```java
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            while (!stack.isEmpty()&&temperatures[i]>temperatures[stack.peek()]){ // 当前元素比栈顶元素对应的数据大
                Integer pop = stack.pop();
                result[pop] = i-pop; // 记录位置
            }
            stack.push(i); // 入栈
        }
        return result;
    }
```

#### 下一个更大元素 I

##### 题目描述

[原题链接](https://leetcode.cn/problems/next-greater-element-i/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/NextGreaterElementI.java)

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

 

**示例 1：**

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

**示例 2：**

```
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
```

 

**提示：**

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 10^4`
- `nums1`和`nums2`中所有整数 **互不相同**
- `nums1` 中的所有整数同样出现在 `nums2` 中

##### 题解

对于每个 `0 <= i < nums1.length` ，需要先找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，然后在 `nums2` 中确定 `nums2[j]` 的 下一个更大元素。所以可以先找出`nums2`中有下一个最大元素的元素并形成映射关系，可以用栈来辅助寻找下一个最大元素

```java
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> map = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        for (int num : nums2) {
            while (!stack.isEmpty() && num > stack.peek()) { //当前元素大于栈顶元素
                map.put(stack.pop(), num); // 当前元素即为栈顶元素的下一个最大元素
            }
            stack.push(num);
        }
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i]= map.getOrDefault(nums1[i], -1); // 根据映射关系保存结果
        }
        return result;
    }
```

#### 下一个更大元素 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/next-greater-element-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/NextGreaterElementII.java)

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

 

**示例 1:**

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

**示例 2:**

```
输入: nums = [1,2,3,4,3]
输出: [2,3,4,-1,4]
```

 

**提示:**

- `1 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`

##### 题解

同样可以使用栈辅助找到下一个最大的数，由于是循环数组所以需要遍历两次

```java
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[nums.length];
        Arrays.fill(result, -1);
        for (int i = 0; i < nums.length; i++) { // 一次遍历
            while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
                result[stack.pop()] = nums[i];
            }
            stack.push(i);
        }
        for (int num : nums) { // 二次遍历
            while (result[stack.peek()] == -1 && num > nums[stack.peek()]) {
                result[stack.pop()] = num;
            }
        }
        return result;
    }
```

### 哈希表

利用 Hash Table 可以快速查找一个元素是否存在等问题，但是需要一定的空间来存储。在优先考虑 时间复杂度的情况下，可以利用 Hash Table 这种空间换取时间的做法。

#### 两数之和

##### 题目描述

[原题链接](https://leetcode.cn/problems/two-sum/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/TwoSum.java)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **只会存在一个有效答案**

##### 题解 

用 `HashMap` 存储数组元素和索引的映射，在访问到 `nums[i]` 时，判断 `HashMap` 中是否存在 `target - nums[i]` ，如果存在说明` target - nums[i]` 所在的索引和 i 就是要找的两个数。

```java
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target-nums[i])) {
                return new int[]{map.get(target-nums[i]),i};
            } else {
                map.put(nums[i],i);
            }
        }
        return null;
    }
```

也可以在此基础上使用双指针进一步降低时间复杂度（如果想要排序后通过双指针或者二分查找来解题，需要提前记录元素对应位置）

```java
    public int[] twoSum2(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        int left = 0,right = nums.length-1;
        while (left<=right){
            int l = target-nums[left];
            int r = target-nums[right];
            if(map.containsKey(l)){
                return new int[]{map.get(l),left};
            } else {
                map.put(nums[left],left++);
            }

            if(map.containsKey(r)){
                return new int[]{map.get(r),right};
            } else {
                map.put(nums[right],right--);
            }
        }
        return null;
    }
```

#### 最长和谐子序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-harmonious-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/LongestHarmoniousSubsequence.java)

和谐数组是指一个数组里元素的最大值和最小值之间的差别 **正好是 `1`** 。

现在，给你一个整数数组 `nums` ，请你在所有可能的子序列中找到最长的和谐子序列的长度。

数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。

 

**示例 1：**

```
输入：nums = [1,3,2,2,5,2,3,7]
输出：5
解释：最长的和谐子序列是 [3,2,2,2,3]
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：2
```

**示例 3：**

```
输入：nums = [1,1,1,1]
输出：0
```

 

**提示：**

- `1 <= nums.length <= 2 * 10^4`
- `-10^9 <= nums[i] <= 10^9`

##### 题解

使用`HashMap` 来存储元素与个数，遍历数组，判断哈希表中是否有相差为1的值（大于或者小于）

```java

    public int findLHS(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>();
        int max = 0;
        for (int num : nums) {
            int count = map.getOrDefault(num, 0); // 获取元素个数
            if(map.containsKey(num-1)){
                max = Math.max(count+1+map.get(num-1),max);
            }
            if(map.containsKey(num+1)){
                max = Math.max(count+1+map.get(num+1),max);
            }
            map.put(num,count+1); // 更新元素个数
        }
        return max;
    }
```

### 字符串

#### 有效的字母异位词

##### 题目描述

[原题链接](https://leetcode.cn/problems/valid-anagram/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ValidAnagram.java)

给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。

**注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。

 

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

 

**提示:**

- `1 <= s.length, t.length <= 5 * 10^4`
- `s` 和 `t` 仅包含小写字母

 

##### 题解

字符串只包含小写字符，总共有 26 个小写字符。可以用数组来记录字符出现的次数，s中出现的字符为其加1，t中出现的字符为其减1，最终判断数组是否全为0

```java
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        int[] count = new int[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        for (int num : count) {
            if (num != 0) {
                return false;
            }
        }
        return true;
    }
```

#### 同构字符串

##### 题目描述

[原题链接](https://leetcode.cn/problems/isomorphic-strings/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/IsomorphicStrings.java)

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

 

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**示例 2：**

```
输入：s = "foo", t = "bar"
输出：false
```

**示例 3：**

```
输入：s = "paper", t = "title"
输出：true
```

 

**提示：**



- `1 <= s.length <= 5 * 10^4`
- `t.length == s.length`
- `s` 和 `t` 由任意有效的 ASCII 字符组成

##### 题解

可以使用哈希表来存储映射关系进行判断

```java
    public boolean isIsomorphic(String s, String t) {
        if(s.length()!=t.length()) return false;
        Map<Character,Character> map = new HashMap<>(256);
        for (int i = 0; i < s.length() ; i++) {
            char c = s.charAt(i);
            if(map.containsKey(c)){ // 已存储映射关系
                if(map.get(c)!=t.charAt(i)) return false; // 不符合映射关系
            } else {
                if(map.containsValue(t.charAt(i))){ // 不同字符不能映射到同一个字符上
                    return false;
                }
                map.put(c,t.charAt(i)); // 添加映射
            }
        }
        return true;
    }
```

也可以使用数组记录一个字符上次出现的位置，如果两个字符串中某个字符上次出现的位置一样，那么就属于同构

```java
    public boolean isIsomorphic2(String s, String t) {
        if(s.length()!=t.length()) return false;
        int[] sc = new int[256];
        int[] tc = new int[256];
        for (int i = 0; i < s.length() ; i++) {
            if(sc[s.charAt(i)]!=tc[t.charAt(i)]) return false;
            sc[s.charAt(i)] = i+1;
            tc[t.charAt(i)] = i+1;
        }
        return true;
    }
```

