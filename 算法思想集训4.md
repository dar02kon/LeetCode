## 数据结构相关

### 栈和队列

#### 用栈实现队列

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementQueueUsingStacks.java)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

 

**示例 1：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```



 

**提示：**

- `1 <= x <= 9`
- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）

##### 题解

使用两个栈，一个用作输出，一个用作输入，当输出栈为空时需要将输入栈的数据转存到输出栈

```java
class MyQueue {
    Stack<Integer> in;// 输入栈
    Stack<Integer> out;// 输出栈

    public MyQueue() {
        in = new Stack<>();
        out = new Stack<>();
    }

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        transform();
        return out.pop();
    }

    public int peek() {
        transform();
        return out.peek();
    }

    public boolean empty() {
        return in.empty() && out.isEmpty();
    }

    private void transform() {
        if (out.isEmpty()) {// 输出栈为空
            while (!in.isEmpty()) {// 将输入栈的数据转存到输出栈
                out.push(in.pop());
            }
        }
    }

}
```

#### 用队列实现栈

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-stack-using-queues/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementStackUsingQueues.java)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

 

**注意：**

- 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

 

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

 

**提示：**

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

 

##### 题解

可以使用一个队列来完成，添加元素后将之前的元素进行反转添加到队列末尾

```java
class MyStack {
    Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.add(x);
        for (int i = 1; i < queue.size(); i++) { // 将之前的元素进行反转
            queue.add(queue.remove());
        }
    }

    public int pop() {
        return queue.isEmpty() ? -1 : queue.poll();
    }

    public int top() {
        return queue.isEmpty() ? -1 : queue.peek();

    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

#### 最小栈

##### 题目描述

[原题链接](https://leetcode.cn/problems/min-stack/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MinStack.java)

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

 

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

 

**提示：**

- `-2^31 <= val <= 2^31 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 10^4` 次

##### 题解

使用两个栈，一个用来存储数据，另一个用来存储对应最小值

```java
class MinStack2 {
    Stack<Integer> input;
    Stack<Integer> min;
    public MinStack2() {
        input = new Stack<>();
        min = new Stack<>();
    }

    public void push(int val) {
        input.push(val);
        if(min.isEmpty()){
            min.push(val);
        } else {
            min.push(Math.min(min.peek(),val));// 存储对应最小值
        }
    }

    public void pop() {
        if(!input.isEmpty()){
            input.pop();
            min.pop();
        }
    }

    public int top() {
        return input.isEmpty()?-1:input.peek();
    }

    public int getMin() {
        return min.isEmpty()?-1:min.peek();
    }
}
```

#### 队列的最大值

##### 题目描述

[原题链接](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MaximumValueOfQueue.java)

请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的**均摊**时间复杂度都是O(1)。

若队列为空，`pop_front` 和 `max_value` 需要返回 -1

**示例 1：**

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

**示例 2：**

```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

 

**限制：**

- `1 <= push_back,pop_front,max_value的总操作数 <= 10000`
- `1 <= value <= 10^5`

##### 题解

使用普通队列来存储数据，使用双端队列来存储最大值。队列遵循后进后出，后面添加的元素存在的时间要长一些，如果后面添加的元素比前面的最大元素大，则应覆盖前面的最大值。出队时，若出队元素等于双端队列的队头元素则应同时出队

```java
class MaxQueue {
    Queue<Integer> queue;
    Deque<Integer> maxDeque;
    public MaxQueue() {
        queue = new LinkedList<>();
        maxDeque = new LinkedList<>();
    }

    public int max_value() {
        if(maxDeque.isEmpty()){
            return -1;
        }
        return maxDeque.peekFirst();
    }

    public void push_back(int value) {
        while (!maxDeque.isEmpty()&&maxDeque.peekLast()<value){ // 覆盖前面的最大值
            maxDeque.pollLast();
        }
        queue.add(value);
        maxDeque.addLast(value);
    }

    public int pop_front() {
        if(queue.isEmpty()){
            return -1;
        }
        Integer poll = queue.poll();
        if(poll.equals(maxDeque.peekFirst())){ // 出队元素恰好为双端队列队头，同时出队
            maxDeque.pollFirst();
        }
        return poll;
    }
}
```

#### 有效的括号

##### 题目描述

[原题链接](https://leetcode.cn/problems/valid-parentheses/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ValidParentheses.java)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

 

**提示：**

- `1 <= s.length <= 10^4`
- `s` 仅由括号 `'()[]{}'` 组成

##### 题解

遍历字符串，当遇到`]`，前面必须有`[`，字符串才有效，`[`不一定紧挨着`]`，中间可能隔着其它符号

可以使用栈来存储左括号，当遍历到的字符为右括号时，判断弹出的栈顶元素是否能匹配，不匹配则字符串无效。若字符串符号有效，遍历结束后，栈应为空

```java
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i <s.length() ; i++) {
            char c = s.charAt(i);
            if(c=='('||c=='['||c=='{'){ // 左括号入栈
                stack.push(c);
            } else { // 判断右括号是否与栈顶元素匹配
                if(stack.isEmpty()){
                    return false;
                }
                Character pop = stack.pop();
                if((c==')'&&pop!='(')||(c==']'&&pop!='[')||(c=='}'&&pop!='{')){
                    return false;
                }
            }
        }
        return stack.isEmpty(); // 最终栈应为空
    }
```

#### 每日温度

##### 题目描述

[原题链接](https://leetcode.cn/problems/daily-temperatures/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/DailyTemperatures.java)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 10^5`
- `30 <= temperatures[i] <= 100`

##### 题解

在遍历数组时用 栈 把数组的下标存起来，如果当前遍历的数比栈顶元素对应的数据大，说明栈顶元素的下一个比它大的数就是当前元素。

```java
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            while (!stack.isEmpty()&&temperatures[i]>temperatures[stack.peek()]){ // 当前元素比栈顶元素对应的数据大
                Integer pop = stack.pop();
                result[pop] = i-pop; // 记录位置
            }
            stack.push(i); // 入栈
        }
        return result;
    }
```

#### 下一个更大元素 I

##### 题目描述

[原题链接](https://leetcode.cn/problems/next-greater-element-i/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/NextGreaterElementI.java)

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

 

**示例 1：**

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

**示例 2：**

```
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
```

 

**提示：**

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 10^4`
- `nums1`和`nums2`中所有整数 **互不相同**
- `nums1` 中的所有整数同样出现在 `nums2` 中

##### 题解

对于每个 `0 <= i < nums1.length` ，需要先找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，然后在 `nums2` 中确定 `nums2[j]` 的 下一个更大元素。所以可以先找出`nums2`中有下一个最大元素的元素并形成映射关系，可以用栈来辅助寻找下一个最大元素

```java
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> map = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        for (int num : nums2) {
            while (!stack.isEmpty() && num > stack.peek()) { //当前元素大于栈顶元素
                map.put(stack.pop(), num); // 当前元素即为栈顶元素的下一个最大元素
            }
            stack.push(num);
        }
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i]= map.getOrDefault(nums1[i], -1); // 根据映射关系保存结果
        }
        return result;
    }
```

#### 下一个更大元素 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/next-greater-element-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/NextGreaterElementII.java)

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

 

**示例 1:**

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

**示例 2:**

```
输入: nums = [1,2,3,4,3]
输出: [2,3,4,-1,4]
```

 

**提示:**

- `1 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`

##### 题解

同样可以使用栈辅助找到下一个最大的数，由于是循环数组所以需要遍历两次

```java
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[nums.length];
        Arrays.fill(result, -1);
        for (int i = 0; i < nums.length; i++) { // 一次遍历
            while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
                result[stack.pop()] = nums[i];
            }
            stack.push(i);
        }
        for (int num : nums) { // 二次遍历
            while (result[stack.peek()] == -1 && num > nums[stack.peek()]) {
                result[stack.pop()] = num;
            }
        }
        return result;
    }
```

### 哈希表

利用 Hash Table 可以快速查找一个元素是否存在等问题，但是需要一定的空间来存储。在优先考虑 时间复杂度的情况下，可以利用 Hash Table 这种空间换取时间的做法。

#### 两数之和

##### 题目描述

[原题链接](https://leetcode.cn/problems/two-sum/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/TwoSum.java)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **只会存在一个有效答案**

##### 题解 

用 `HashMap` 存储数组元素和索引的映射，在访问到 `nums[i]` 时，判断 `HashMap` 中是否存在 `target - nums[i]` ，如果存在说明` target - nums[i]` 所在的索引和 i 就是要找的两个数。

```java
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target-nums[i])) {
                return new int[]{map.get(target-nums[i]),i};
            } else {
                map.put(nums[i],i);
            }
        }
        return null;
    }
```

也可以在此基础上使用双指针进一步降低时间复杂度（如果想要排序后通过双指针或者二分查找来解题，需要提前记录元素对应位置）

```java
    public int[] twoSum2(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        int left = 0,right = nums.length-1;
        while (left<=right){
            int l = target-nums[left];
            int r = target-nums[right];
            if(map.containsKey(l)){
                return new int[]{map.get(l),left};
            } else {
                map.put(nums[left],left++);
            }

            if(map.containsKey(r)){
                return new int[]{map.get(r),right};
            } else {
                map.put(nums[right],right--);
            }
        }
        return null;
    }
```

#### 最长和谐子序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-harmonious-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/LongestHarmoniousSubsequence.java)

和谐数组是指一个数组里元素的最大值和最小值之间的差别 **正好是 `1`** 。

现在，给你一个整数数组 `nums` ，请你在所有可能的子序列中找到最长的和谐子序列的长度。

数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。

 

**示例 1：**

```
输入：nums = [1,3,2,2,5,2,3,7]
输出：5
解释：最长的和谐子序列是 [3,2,2,2,3]
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：2
```

**示例 3：**

```
输入：nums = [1,1,1,1]
输出：0
```

 

**提示：**

- `1 <= nums.length <= 2 * 10^4`
- `-10^9 <= nums[i] <= 10^9`

##### 题解

使用`HashMap` 来存储元素与个数，遍历数组，判断哈希表中是否有相差为1的值（大于或者小于）

```java

    public int findLHS(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>();
        int max = 0;
        for (int num : nums) {
            int count = map.getOrDefault(num, 0); // 获取元素个数
            if(map.containsKey(num-1)){
                max = Math.max(count+1+map.get(num-1),max);
            }
            if(map.containsKey(num+1)){
                max = Math.max(count+1+map.get(num+1),max);
            }
            map.put(num,count+1); // 更新元素个数
        }
        return max;
    }
```

### 字符串

#### 有效的字母异位词

##### 题目描述

[原题链接](https://leetcode.cn/problems/valid-anagram/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ValidAnagram.java)

给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。

**注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。

 

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

 

**提示:**

- `1 <= s.length, t.length <= 5 * 10^4`
- `s` 和 `t` 仅包含小写字母

 

##### 题解

字符串只包含小写字符，总共有 26 个小写字符。可以用数组来记录字符出现的次数，s中出现的字符为其加1，t中出现的字符为其减1，最终判断数组是否全为0

```java
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        int[] count = new int[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        for (int num : count) {
            if (num != 0) {
                return false;
            }
        }
        return true;
    }
```

#### 同构字符串

##### 题目描述

[原题链接](https://leetcode.cn/problems/isomorphic-strings/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/IsomorphicStrings.java)

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

 

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**示例 2：**

```
输入：s = "foo", t = "bar"
输出：false
```

**示例 3：**

```
输入：s = "paper", t = "title"
输出：true
```

 

**提示：**



- `1 <= s.length <= 5 * 10^4`
- `t.length == s.length`
- `s` 和 `t` 由任意有效的 ASCII 字符组成

##### 题解

可以使用哈希表来存储映射关系进行判断

```java
    public boolean isIsomorphic(String s, String t) {
        if(s.length()!=t.length()) return false;
        Map<Character,Character> map = new HashMap<>(256);
        for (int i = 0; i < s.length() ; i++) {
            char c = s.charAt(i);
            if(map.containsKey(c)){ // 已存储映射关系
                if(map.get(c)!=t.charAt(i)) return false; // 不符合映射关系
            } else {
                if(map.containsValue(t.charAt(i))){ // 不同字符不能映射到同一个字符上
                    return false;
                }
                map.put(c,t.charAt(i)); // 添加映射
            }
        }
        return true;
    }
```

也可以使用数组记录一个字符上次出现的位置，如果两个字符串中某个字符上次出现的位置一样，那么就属于同构

```java
    public boolean isIsomorphic2(String s, String t) {
        if(s.length()!=t.length()) return false;
        int[] sc = new int[256];
        int[] tc = new int[256];
        for (int i = 0; i < s.length() ; i++) {
            if(sc[s.charAt(i)]!=tc[t.charAt(i)]) return false;
            sc[s.charAt(i)] = i+1;
            tc[t.charAt(i)] = i+1;
        }
        return true;
    }
```

#### 最长回文串

##### 题目描述

[原题链接](https://leetcode.cn/problems/longest-palindrome/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/LongestPalindrome.java)

给定一个包含大写字母和小写字母的字符串 `s` ，返回 *通过这些字母构造成的 **最长的回文串*** 。

在构造过程中，请注意 **区分大小写** 。比如 `"Aa"` 不能当做一个回文字符串。

 

**示例 1:**

```
输入:s = "abccccdd"
输出:7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

**示例 2:**

```
输入:s = "a"
输出:1
```

**示例 3：**

```
输入:s = "aaaaaccc"
输出:7
```

 

**提示:**

- `1 <= s.length <= 2000`
- `s` 只由小写 **和/或** 大写英文字母组成

##### 题解

使用长度为 128 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。

```java
    public int longestPalindrome(String s) {
        int[] count = new int[128];
        for (int i = 0; i <s.length() ; i++) {
            count[s.charAt(i)]++;
        }
        int sum = 0;
        for (int num : count) {
            sum+=num/2*2; // 取最大偶数
        }
        return sum<s.length()?sum+1:sum; // 中间可能有单独字符
    }
```

####  回文数

##### 题目描述

[原题链接](https://leetcode.cn/problems/palindrome-number/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/PalindromeNumber.java)

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

 

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

 

**提示：**

- `-2^31 <= x <= 2^31 - 1`

##### 题解

将 x 进行倒序比较

```java
    public boolean isPalindrome(int x) {
        if(x==0) return true;
        if(x<0||x%10==0) return false; // x以0结尾倒序首位为0
        int reverse = 0;
        int temp = x;
        while (temp!=0){ 
            reverse = reverse*10+temp%10;
            temp/=10;
        }
        return x==reverse;
    }
```

仿照回文串将x的后半部分进行倒序与前半部分进行比较

```java
    public boolean isPalindrome2(int x) {
        if(x==0) return true;
        if(x<0||x%10==0) return false;

        int reverse = 0;
        while (x>reverse){ // 倒序一半
            reverse = reverse*10+x%10;
            x/=10;
        }
        return x==reverse||x==reverse/10; // x为奇数时中间一位可以忽略
    }
```

#### 回文子串

##### 题目描述

[原题链接](https://leetcode.cn/problems/palindromic-substrings/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/PalindromicSubstrings.java)

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成

##### 题解

从字符串的某一位开始，尝试着去扩展子字符串。对于已经确定的回文串在其左右添加相同的字符仍然构成一个回文串

```java

    int result = 0;
    public int countSubstrings(String s) {
        for (int i = 0; i < s.length(); i++) {
            statistics(s,i,i); // 奇数个字符构成的回文串
            statistics(s,i-1,i); // 偶数个字符构成的回文串
        }
        return result;
    }

    private void statistics(String s, int left, int right) {
        while (left>=0&&right<s.length()&&s.charAt(left)==s.charAt(right)){ // 尝试扩展
            left--;
            right++;
            result++;
        }
    }
```

#### 计数二进制子串

##### 题目描述

[原题链接](https://leetcode.cn/problems/count-binary-substrings/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/CountBinarySubstrings.java)

给定一个字符串 `s`，统计并返回具有相同数量 `0` 和 `1` 的非空（连续）子字符串的数量，并且这些子字符串中的所有 `0` 和所有 `1` 都是成组连续的。

重复出现（不同位置）的子串也要统计它们出现的次数。

 

**示例 1：**

```
输入：s = "00110011"
输出：6
解释：6 个子串满足具有相同数量的连续 1 和 0 ："0011"、"01"、"1100"、"10"、"0011" 和 "01" 。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。
```

**示例 2：**

```
输入：s = "10101"
输出：4
解释：有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。
```

 

**提示：**

- `1 <= s.length <= 10^5`
- `s[i]` 为 `'0'` 或 `'1'`

##### 题解

根据0，1对字符串进行分组，统计每一组0或1的个数，例如`00110011`可以分组为`[2,2,2,2]`，相邻两组均不相同。2个0与2个1可以组成两个符合要求的子串，2个0与4个1同样可以组成两个符合要求的子串，两者取其小。

所以可以从前往后遍历字符串，统计在一起的0或1的个数，出现相邻两组时即可计算符合要求的子串数量

```java
    public int countBinarySubstrings(String s) {
        int index = 0; // 遍历的下标索引
        int result = 0; // 结果
        int temp = 0; // 前面一组的字符数量
        int count; // 当前一组的字符数量
        while (index<s.length()){
            count = 0;
            char c = s.charAt(index);
            while (index<s.length()&&s.charAt(index)==c){ // 统计当前一组字符数量
                count++;
                index++;
            }
            result+=Math.min(count,temp); // 两组取其小
            temp = count; // 更新上一组数量
        }
        return result;
    }
```

### 数组与矩阵

#### 移动零

##### 题目描述

[原题链接](https://leetcode.cn/problems/move-zeroes/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MoveZeroes.java)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

 

**提示**:

- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

##### 题解

寻找数组中的非0数字，从前往后依次进行填充，最后在数组末尾填充0

```java
    public void moveZeroes(int[] nums) {
        int index = 0;
        for (int num : nums) { // 遍历数组
            if(num!=-0) nums[index++] = num; // 按顺序填充非0数字
        }
        while (index<nums.length){ // 尾部填充0
            nums[index++] = 0;
        }
    }
```

#### 错误的集合

##### 题目描述

[原题链接](https://leetcode.cn/problems/set-mismatch/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/SetMismatch.java)

集合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

 

**示例 1：**

```
输入：nums = [1,2,2,4]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[1,2]
```

 

**提示：**

- `2 <= nums.length <= 10^4`
- `1 <= nums[i] <= 10^4`

##### 题解

可以通过交换数组元素，使得数组上的元素在正确的位置上，即`nums[i] = i+1`，当`nums[i] != i+1`时，我们虽然不确定i+1是否存在，但可以确定`nums[i]`对应的位置应为`nums[i]-1`，那么就交换第 i 位 和 `nums[i] - 1` 位上的元素，使得`nums[nums[i] - 1] = nums[i] `

交换操作需要循环进行，因为一次交换没办法使得第 i 位上的元素是正确的。但是要交换的两个元素可能就是重复元素，那么循环就可能永远进行 下去，终止循环的方法是加上 `nums[i] != nums[nums[i] - 1]` 条件。

```java
    public int[] findErrorNums(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) { // 交换元素
                swap(nums, i, nums[i] - 1);
            }
        }
        for (int i = 0; i < nums.length; i++) { // 寻找错误的位置
            if (nums[i] != i + 1) {
                return new int[]{nums[i], i + 1};
            }
        }
        return null;
    }

    // 交换
    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
```

#### 找到所有数组中消失的数字

##### 题目描述

[原题链接](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/FindAllNumbersDisappearedInAnArray.java)

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

 

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[2]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 10^5`
- `1 <= nums[i] <= n`

##### 题解

将数字与数组下标形成映射关系，即`nums[i] = i+1`，当`nums[i] != i+1`时，我们虽然不确定i+1是否存在，但可以确定`nums[i]`对应的位置应为`nums[i]-1`，那么就交换第 i 位 和 `nums[i] - 1` 位上的元素，使得`nums[nums[i] - 1] = nums[i] `

交换操作需要循环进行，因为一次交换没办法使得第 i 位上的元素是正确的。但是要交换的两个元素可能就是重复元素，那么循环就可能永远进行 下去，终止循环的方法是加上 `nums[i] != nums[nums[i] - 1]` 条件。

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) { // 循环交换
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }

        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) { // 查询结果
            if (nums[i] != i + 1) {
                list.add(i+1);
            }
        }
        return list;
    }
```

#### 数组中重复的数据

##### 题目描述

[原题链接](https://leetcode.cn/problems/find-all-duplicates-in-an-array/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/FindAllDuplicatesInAnArray.java)

给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **一次** 或 **两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。

你必须设计并实现一个时间复杂度为 `O(n)` 且仅使用常量额外空间的算法解决此问题。

 

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1,2]
输出：[1]
```

**示例 3：**

```
输入：nums = [1]
输出：[]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 10^5`
- `1 <= nums[i] <= n`
- `nums` 中的每个元素出现 **一次** 或 **两次**

##### 题解

与前面两题的思路相同，都是通过交换元素形成映射关系，最终去寻找特例，即没有形成映射关系的元素

```java
    public List<Integer> findDuplicates(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i]!=i+1&&nums[i]!=nums[nums[i]-1]){ // 交换元素
                int temp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = temp;
            }
        }

        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) { // 查询结果
            if(nums[i]!=i+1){
                list.add(nums[i]);
            }
        }
        return list;
    }
```

