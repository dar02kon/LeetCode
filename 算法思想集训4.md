## 数据结构相关

### 栈和队列

#### 用栈实现队列

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementQueueUsingStacks.java)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

 

**示例 1：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```



 

**提示：**

- `1 <= x <= 9`
- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）

##### 题解

使用两个栈，一个用作输出，一个用作输入，当输出栈为空时需要将输入栈的数据转存到输出栈

```java
class MyQueue {
    Stack<Integer> in;// 输入栈
    Stack<Integer> out;// 输出栈

    public MyQueue() {
        in = new Stack<>();
        out = new Stack<>();
    }

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        transform();
        return out.pop();
    }

    public int peek() {
        transform();
        return out.peek();
    }

    public boolean empty() {
        return in.empty() && out.isEmpty();
    }

    private void transform() {
        if (out.isEmpty()) {// 输出栈为空
            while (!in.isEmpty()) {// 将输入栈的数据转存到输出栈
                out.push(in.pop());
            }
        }
    }

}
```

#### 用队列实现栈

##### 题目描述

[原题链接](https://leetcode.cn/problems/implement-stack-using-queues/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/ImplementStackUsingQueues.java)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

 

**注意：**

- 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

 

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

 

**提示：**

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

 

##### 题解

可以使用一个队列来完成，添加元素后将之前的元素进行反转添加到队列末尾

```java
class MyStack {
    Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.add(x);
        for (int i = 1; i < queue.size(); i++) { // 将之前的元素进行反转
            queue.add(queue.remove());
        }
    }

    public int pop() {
        return queue.isEmpty() ? -1 : queue.poll();
    }

    public int top() {
        return queue.isEmpty() ? -1 : queue.peek();

    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

#### 最小栈

##### 题目描述

[原题链接](https://leetcode.cn/problems/min-stack/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MinStack.java)

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

 

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

 

**提示：**

- `-2^31 <= val <= 2^31 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 10^4` 次

##### 题解

使用两个栈，一个用来存储数据，另一个用来存储对应最小值

```java
class MinStack2 {
    Stack<Integer> input;
    Stack<Integer> min;
    public MinStack2() {
        input = new Stack<>();
        min = new Stack<>();
    }

    public void push(int val) {
        input.push(val);
        if(min.isEmpty()){
            min.push(val);
        } else {
            min.push(Math.min(min.peek(),val));// 存储对应最小值
        }
    }

    public void pop() {
        if(!input.isEmpty()){
            input.pop();
            min.pop();
        }
    }

    public int top() {
        return input.isEmpty()?-1:input.peek();
    }

    public int getMin() {
        return min.isEmpty()?-1:min.peek();
    }
}
```

#### 队列的最大值

##### 题目描述

[原题链接](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/data_structure/MaximumValueOfQueue.java)

请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的**均摊**时间复杂度都是O(1)。

若队列为空，`pop_front` 和 `max_value` 需要返回 -1

**示例 1：**

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

**示例 2：**

```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

 

**限制：**

- `1 <= push_back,pop_front,max_value的总操作数 <= 10000`
- `1 <= value <= 10^5`

##### 题解

使用普通队列来存储数据，使用双端队列来存储最大值。队列遵循后进后出，后面添加的元素存在的时间要长一些，如果后面添加的元素比前面的最大元素大，则应覆盖前面的最大值。出队时，若出队元素等于双端队列的队头元素则应同时出队

```java
class MaxQueue {
    Queue<Integer> queue;
    Deque<Integer> maxDeque;
    public MaxQueue() {
        queue = new LinkedList<>();
        maxDeque = new LinkedList<>();
    }

    public int max_value() {
        if(maxDeque.isEmpty()){
            return -1;
        }
        return maxDeque.peekFirst();
    }

    public void push_back(int value) {
        while (!maxDeque.isEmpty()&&maxDeque.peekLast()<value){ // 覆盖前面的最大值
            maxDeque.pollLast();
        }
        queue.add(value);
        maxDeque.addLast(value);
    }

    public int pop_front() {
        if(queue.isEmpty()){
            return -1;
        }
        Integer poll = queue.poll();
        if(poll.equals(maxDeque.peekFirst())){ // 出队元素恰好为双端队列队头，同时出队
            maxDeque.pollFirst();
        }
        return poll;
    }
}
```



