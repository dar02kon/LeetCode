# LeetCode刷题记录

**刷刷题，做做笔记只是为了我自己身心愉悦**

## 已刷算法题

### 简单

* [二进制求和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/AddBinary.java)
* [最后一个单词的长度](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/LengthOfLastWord.java)
* [最长公共前缀](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/LongestCommonPrefix.java)
* [合并两个有序链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MergeTwoSortedLists.java)
* [回文数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PalindromeNumber.java)
* [加一](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PlusOne.java)
* [删除有序数组中的重复项](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveDuplicatesFromSortedArray.java)
* [移除元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveElement.java)
* [罗马数字转整数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RomanToInteger.java)
* [搜索插入位置](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SearchInsertPosition.java)
* [有效的括号](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ValidParentheses.java)
* [x 的平方根](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/Sqrtx.java)
* [删除排序链表中的重复元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveDuplicatesFromSortedList.java)
* [爬楼梯](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ClimbingStairs.java)
* [合并两个有序数组](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MergeSortedArray.java)
* [二叉树的中序遍历](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BinaryTreeInorderTraversal.java)
* [相同的树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SameTree.java)
* [对称二叉树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SymmetricTree.java)
* [二叉树的最大深度](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MaximumDepthOfBinaryTree.java)
* [平衡二叉树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BalancedBinaryTree.java)
* [将有序数组转换为二叉搜索树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ConvertSortedArrayToBinarySearchTree.java)
* [验证回文串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ValidPalindrome.java)
* [路径总和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PathSum.java)
* [二叉树的最小深度](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MinimumDepthOfBinaryTree.java)
* [杨辉三角](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PascalsTriangle.java)
* [杨辉三角 II](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PascalsTriangleIi.java)
* [买卖股票的最佳时机](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BestTimeToBuyAndSellStock.java)
* [只出现一次的数字](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SingleNumber.java)
* [环形链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/LinkedListCycle.java)
* [二叉树的前序遍历](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BinaryTreePreorderTraversal.java)
* [二叉树的后序遍历](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BinaryTreePostorderTraversal.java)
* [Excel表列名称](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ExcelSheetColumnTitle.java)
* [相交链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/IntersectionOfTwoLinkedLists.java)
* [多数元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MajorityElement.java)
* [Excel 表列序号](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ExcelSheetColumnNumber.java)
* [颠倒二进制位](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ReverseBits.java)
* [位1的个数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/NumberOf1Bits.java)
* [移除链表元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveLinkedListElements.java)
* [快乐数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/HappyNumber.java)
* [反转链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ReverseLinkedList.java)
* [同构字符串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/IsomorphicStrings.java)
* [存在重复元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ContainsDuplicate.java)
* [存在重复元素 II](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ContainsDuplicateII.java)
* [翻转二叉树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/InvertBinaryTree.java)
* [用队列实现栈](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ImplementStackUsingQueues.java)

### 中等

* [两数相加](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/AddTwoNumbers.java)
* [无重复字符的最长子串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/LongestSubstringWithoutRepeatingCharacters.java)
* [最长回文子串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/LongestPalindromicSubstring.java)

### 困难

## 算法

### 滑动窗口

**算法思想：**

滑动窗口是双指针的一种特例，可以称为左右指针，在任意时刻，只有一个指针运动，而另一个保持静止。滑动窗口路一般用于解决特定的序列中符合条件的连续的子序列的问题。

滑动窗口的时间复杂度是线性的，一般为O ( n ) ,滑动窗口的左右边界都不会向左滑动，向左滑动等于走回头路，是一种回溯的算法，很可能会陷入死循环。
滑动窗口是一种全遍历问题，一定会遍历到末尾的。
其本质思路在于：

* 初始化将滑动窗口压满，取得第一个滑动窗口的目标值
* 继续滑动窗口，每往前滑动一次，需要删除一个和添加一个元素，求最优的目标值

TCP利用滑动窗口实现流量控制（流量控制就是让发送方的发送速率不要太快，要让接受方来得及接受），发送方的发送窗口不能超过接收方给出的接受窗口（窗口单位是字节，不是报文段）。

（1）接收端将自己缓冲区大小放进TCP头部的“窗口大小”字段，通过ACK告知发送端；

（2）窗口大小是指无需等待确认应答而可以一次连续发送数据的最大值；

（3）操作系统内核为了维护滑动窗口，需开辟发送缓冲区，来记录哪些数据还没有被应答，只有确认应答后才从缓冲区删除；

（4）接收端发现自己缓存区快满了，将窗口大小设置更小发送给发送端，发送端收到后就会减慢发送速度；

（5）接收端发现自己缓冲区满了，将窗口大小设置为0，此时发送端没有停止发送数据，而是定期发送（持续计时器）一个零窗口探测报文段（仅携带1字节的数据），让接收端告诉它的窗口大小，若窗口不是零，则死锁的僵局就可以打破；若仍然为零，收到这个报文段的一方就重新设置持续计时器。

相关题目：

* [存在重复元素 II](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ContainsDuplicateII.java)
* [无重复字符的最长子串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/LongestSubstringWithoutRepeatingCharacters.java)



### Boyer-Moore 投票算法

**算法实现思路：**

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate。

随后我们判断 x：

​	如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

​	如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

注：数组中占比超过一半的元素称之为主要元素（众数）。

**分析：**

开始投票

 假设max是多数元素（主要元素/众数）即在数组中出现次数 大于n/2（n为数组长度）的元素，这说明max在进场前就已经托关系保证一般以上的人会选他
* 如果我们想知道结果谁会赢，这当然是max，因为我们提前知道他有一半以上的票，所以结果max会获胜

* 假设我们提前不知道谁票数最多，想要通过选举的结果来判断，我们当然会选最终赢的人，因为只有票数最多才会赢

  

* 在选举之前就可以确定max已经占了一般以上的票数（因为有一般以上的人支持他）

* 如果候选人不是max，则支持max那一半以上的人都会投反对票（计数器为0时换人）

*     如果max是候选人，则会有一半以上的人投他，即使中途出现过换人，他还是会重返舞台，因为赞成和反对抵消后，最终只会剩下支持他的人

相关题目：

* [多数元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MajorityElement.java)

### Floyd 判圈算法（龟兔赛跑算法）

这个算法思想我的理解是就像我们在围绕操场跑步，两个人从同一个起点同一时刻开始跑，跑的快的那个人总会追上跑的慢的那个人，第二次相遇在基于第一次相遇（起点不算）的基础上，跑到快的那个人多跑了一个环。

这个思想就可以作为一些问题的解决方案

1、判断是否有环

使用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等），那么说明链表有环，如果快指针（兔）到达了链表的结尾，那么说明没环。

2、求环的长度

相遇的时候，两人一定已经在环上了，只要在环上接着跑，再次相遇的时候，跑的快的那个人就比跑的慢的那个人整整多跑了一圈，所以环的长度也就出来了。

3、确定环的起点

设乌龟走过的全部路程为i，m是表头和环的起点之间的距离，n是环的起点和相遇点之间的距离，L为环的长度

那么有

**i = m + n + aL** **（1）**「a是乌龟绕过的环的圈数」

因为兔子的速度是乌龟的两倍，所以有

**2i = m + n + bL（2）**「b是兔子绕过的环的圈数」

**(2) - (1)**可得：

**i = (b - a)L （3）**

结合式子(1)、(3)可得 m + n + aL = (b - a)L，所以有

**m + n = (b-2a)L（4）**{因为m+n>0且L>0, 所以b-2a>=1}

**所以可以得出结论：**

**m + n = 环长度L的正整数倍。（5）**

**当乌龟和兔子第一次相遇后，让乌龟回到起点，兔子仍在相遇点，乌龟以每次1步的速度向前走，兔子以相同的速度绕环逆时针前进**。当走了m步时，兔子和乌龟正好都在环的起点。因为兔子相对于A点走了(n+m)步，由结论(5)可知此时的相遇点必然是环的起点。

相关题目：

* [环形链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/LinkedListCycle.java)
* [快乐数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/HappyNumber.java)

### 双指针

设置两个指针（变量）不断进行单向移动来解决问题的算法。

原本两个指针是有 n<sup>2</sup>种组合，因此时间复杂度是 O(n<sup>2</sup>) 。
而双指针算法就是运用单调性使得指针只能单向移动，因此总的时间复杂度只有 O(n)。

之所以双指针可以实现 O(n) 的时间复杂度是因为指针只能单向移动，没有指针的回溯，而且每一步都会有指针移动。

而朴素的 O(n<sup>2</sup>) 算法的问题就在于指针经常**回溯到之前的位置**。

相关题目：

* [移除元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveElement.java)
* [删除有序数组中的重复项](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveDuplicatesFromSortedArray.java)
* [合并两个有序数组](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MergeSortedArray.java)
* [验证回文串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ValidPalindrome.java)
* [相交链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/IntersectionOfTwoLinkedLists.java)

### 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

```java

    /**
     * 从数组nums中寻找target，找到返回true，否则返回false
     */
    public boolean search(int[] nums, int target) {
       int left = 0;
       int right = nums.length;
       while (left<=right){
           //考虑到可能发生的整型溢出，使用 left + (right - left)/2 取mid更安全一点。
           int mid = left + (right - left) / 2;
           if(target == nums[mid]){
               return true;
           } else if(target < nums[mid]){
               right = mid - 1;
           } else {
               left = mid + 1;
           }
       }
       return false;
    }
```

相关题目：

* [搜索插入位置](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SearchInsertPosition.java)
* [x 的平方根](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/Sqrtx.java)
