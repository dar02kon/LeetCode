# LeetCode刷题记录

**刷刷题，做做笔记只是为了我自己身心愉悦**

## 已刷算法题

### 简单

* [二进制求和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/AddBinary.java)
* [最后一个单词的长度](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/LengthOfLastWord.java)
* [最长公共前缀](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/LongestCommonPrefix.java)
* [合并两个有序链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MergeTwoSortedLists.java)
* [回文数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PalindromeNumber.java)
* [加一](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PlusOne.java)
* [删除有序数组中的重复项](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveDuplicatesFromSortedArray.java)
* [移除元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveElement.java)
* [罗马数字转整数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RomanToInteger.java)
* [搜索插入位置](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SearchInsertPosition.java)
* [有效的括号](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ValidParentheses.java)
* [x 的平方根](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/Sqrtx.java)
* [删除排序链表中的重复元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveDuplicatesFromSortedList.java)
* [爬楼梯](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ClimbingStairs.java)
* [合并两个有序数组](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MergeSortedArray.java)
* [二叉树的中序遍历](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BinaryTreeInorderTraversal.java)
* [相同的树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SameTree.java)
* [对称二叉树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SymmetricTree.java)
* [二叉树的最大深度](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MaximumDepthOfBinaryTree.java)
* [平衡二叉树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BalancedBinaryTree.java)
* [将有序数组转换为二叉搜索树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ConvertSortedArrayToBinarySearchTree.java)
* [验证回文串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ValidPalindrome.java)
* [路径总和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PathSum.java)
* [二叉树的最小深度](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MinimumDepthOfBinaryTree.java)
* [杨辉三角](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PascalsTriangle.java)
* [杨辉三角 II](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/PascalsTriangleIi.java)
* [买卖股票的最佳时机](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BestTimeToBuyAndSellStock.java)
* [只出现一次的数字](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SingleNumber.java)
* [环形链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/LinkedListCycle.java)
* [二叉树的前序遍历](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BinaryTreePreorderTraversal.java)
* [二叉树的后序遍历](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/BinaryTreePostorderTraversal.java)
* [Excel表列名称](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ExcelSheetColumnTitle.java)
* [相交链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/IntersectionOfTwoLinkedLists.java)
* [多数元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MajorityElement.java)
* [Excel 表列序号](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ExcelSheetColumnNumber.java)
* [颠倒二进制位](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ReverseBits.java)
* [位1的个数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/NumberOf1Bits.java)
* [移除链表元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveLinkedListElements.java)
* [快乐数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/HappyNumber.java)
* [反转链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ReverseLinkedList.java)
* [同构字符串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/IsomorphicStrings.java)
* [存在重复元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ContainsDuplicate.java)
* [存在重复元素 II](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ContainsDuplicateII.java)
* [翻转二叉树](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/InvertBinaryTree.java)
* [用队列实现栈](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ImplementStackUsingQueues.java)

### 中等

* [两数相加](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/AddTwoNumbers.java)
* [无重复字符的最长子串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/LongestSubstringWithoutRepeatingCharacters.java)
* [最长回文子串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/LongestPalindromicSubstring.java)
* [Z 字形变换](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ZigzagConversion.java)
* [整数反转](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ReverseInteger.java)
* [字符串转换整数 (atoi)](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/StringToIntegerAtoi.java)
* [盛最多水的容器](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ContainerWithMostWater.java)
* [整数转罗马数字](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/IntegerToRoman.java)
* [三数之和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ThreeSum.java)
* [最接近的三数之和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ThreeSumClosest.java)
* [电话号码的字母组合](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/LetterCombinationsOfAPhoneNumber.java)
* [四数之和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/FourSum.java)
* [删除链表的倒数第 N 个结点](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/RemoveNthNodeFromEndOfList.java)
* [括号生成](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/GenerateParentheses.java)
* [两两交换链表中的节点](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/SwapNodesInPairs.java)
* [找出字符串中第一个匹配项的下标](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/FindTheIndexOfTheFirstOccurrenceInAString.java)
* [两数相除](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/DivideTwoIntegers.java)
* [下一个排列](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/NextPermutation.java)
* [搜索旋转排序数组](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/SearchInRotatedSortedArray.java)
* [在排序数组中查找元素的第一个和最后一个位置](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/FindFirstAndLastPositionOfElementInSortedArray.java)
* [有效的数独](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ValidSudoku.java)

### 困难

## 算法

### 滑动窗口

**算法思想：**

滑动窗口是双指针的一种特例，可以称为左右指针，在任意时刻，只有一个指针运动，而另一个保持静止。滑动窗口路一般用于解决特定的序列中符合条件的连续的子序列的问题。

滑动窗口的时间复杂度是线性的，一般为O ( n ) ,滑动窗口的左右边界都不会向左滑动，向左滑动等于走回头路，是一种回溯的算法，很可能会陷入死循环。
滑动窗口是一种全遍历问题，一定会遍历到末尾的。
其本质思路在于：

* 初始化将滑动窗口压满，取得第一个滑动窗口的目标值
* 继续滑动窗口，每往前滑动一次，需要删除一个和添加一个元素，求最优的目标值

TCP利用滑动窗口实现流量控制（流量控制就是让发送方的发送速率不要太快，要让接受方来得及接受），发送方的发送窗口不能超过接收方给出的接受窗口（窗口单位是字节，不是报文段）。

（1）接收端将自己缓冲区大小放进TCP头部的“窗口大小”字段，通过ACK告知发送端；

（2）窗口大小是指无需等待确认应答而可以一次连续发送数据的最大值；

（3）操作系统内核为了维护滑动窗口，需开辟发送缓冲区，来记录哪些数据还没有被应答，只有确认应答后才从缓冲区删除；

（4）接收端发现自己缓存区快满了，将窗口大小设置更小发送给发送端，发送端收到后就会减慢发送速度；

（5）接收端发现自己缓冲区满了，将窗口大小设置为0，此时发送端没有停止发送数据，而是定期发送（持续计时器）一个零窗口探测报文段（仅携带1字节的数据），让接收端告诉它的窗口大小，若窗口不是零，则死锁的僵局就可以打破；若仍然为零，收到这个报文段的一方就重新设置持续计时器。

相关题目：

* [存在重复元素 II](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ContainsDuplicateII.java)
* [无重复字符的最长子串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/LongestSubstringWithoutRepeatingCharacters.java)



### Boyer-Moore 投票算法

**算法实现思路：**

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate。

随后我们判断 x：

​	如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

​	如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

注：数组中占比超过一半的元素称之为主要元素（众数）。

**分析：**

开始投票

 假设max是多数元素（主要元素/众数）即在数组中出现次数 大于n/2（n为数组长度）的元素，这说明max在进场前就已经托关系保证一般以上的人会选他
* 如果我们想知道结果谁会赢，这当然是max，因为我们提前知道他有一半以上的票，所以结果max会获胜

* 假设我们提前不知道谁票数最多，想要通过选举的结果来判断，我们当然会选最终赢的人，因为只有票数最多才会赢

  

* 在选举之前就可以确定max已经占了一般以上的票数（因为有一般以上的人支持他）

* 如果候选人不是max，则支持max那一半以上的人都会投反对票（计数器为0时换人）

*     如果max是候选人，则会有一半以上的人投他，即使中途出现过换人，他还是会重返舞台，因为赞成和反对抵消后，最终只会剩下支持他的人

相关题目：

* [多数元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MajorityElement.java)

### Floyd 判圈算法（龟兔赛跑算法）

这个算法思想我的理解是就像我们在围绕操场跑步，两个人从同一个起点同一时刻开始跑，跑的快的那个人总会追上跑的慢的那个人，第二次相遇在基于第一次相遇（起点不算）的基础上，跑到快的那个人多跑了一个环。

这个思想就可以作为一些问题的解决方案

1、判断是否有环

使用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等），那么说明链表有环，如果快指针（兔）到达了链表的结尾，那么说明没环。

2、求环的长度

相遇的时候，两人一定已经在环上了，只要在环上接着跑，再次相遇的时候，跑的快的那个人就比跑的慢的那个人整整多跑了一圈，所以环的长度也就出来了。

3、确定环的起点

设乌龟走过的全部路程为i，m是表头和环的起点之间的距离，n是环的起点和相遇点之间的距离，L为环的长度

那么有

**i = m + n + aL** **（1）**「a是乌龟绕过的环的圈数」

因为兔子的速度是乌龟的两倍，所以有

**2i = m + n + bL（2）**「b是兔子绕过的环的圈数」

**(2) - (1)**可得：

**i = (b - a)L （3）**

结合式子(1)、(3)可得 m + n + aL = (b - a)L，所以有

**m + n = (b-2a)L（4）**{因为m+n>0且L>0, 所以b-2a>=1}

**所以可以得出结论：**

**m + n = 环长度L的正整数倍。（5）**

**当乌龟和兔子第一次相遇后，让乌龟回到起点，兔子仍在相遇点，乌龟以每次1步的速度向前走，兔子以相同的速度绕环逆时针前进**。当走了m步时，兔子和乌龟正好都在环的起点。因为兔子相对于A点走了(n+m)步，由结论(5)可知此时的相遇点必然是环的起点。

相关题目：

* [环形链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/LinkedListCycle.java)
* [快乐数](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/HappyNumber.java)

### 双指针

设置两个指针（变量）不断进行单向移动来解决问题的算法。

原本两个指针是有 n<sup>2</sup>种组合，因此时间复杂度是 O(n<sup>2</sup>) 。
而双指针算法就是运用单调性使得指针只能单向移动，因此总的时间复杂度只有 O(n)。

之所以双指针可以实现 O(n) 的时间复杂度是因为指针只能单向移动，没有指针的回溯，而且每一步都会有指针移动。

而朴素的 O(n<sup>2</sup>) 算法的问题就在于指针经常**回溯到之前的位置**。

相关题目：

* [移除元素](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveElement.java)
* [删除有序数组中的重复项](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/RemoveDuplicatesFromSortedArray.java)
* [合并两个有序数组](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/MergeSortedArray.java)
* [验证回文串](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/ValidPalindrome.java)
* [相交链表](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/IntersectionOfTwoLinkedLists.java)
* [盛最多水的容器](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ContainerWithMostWater.java)
* [三数之和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ThreeSum.java)
* [最接近的三数之和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/ThreeSumClosest.java)
* [四数之和](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/FourSum.java)
* [删除链表的倒数第 N 个结点](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/RemoveNthNodeFromEndOfList.java)

### 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

```java

    /**
     * 从数组nums中寻找target，找到返回true，否则返回false
     */
    public boolean search(int[] nums, int target) {
       int left = 0;
       int right = nums.length;
       while (left<=right){
           //考虑到可能发生的整型溢出，使用 left + (right - left)/2 取mid更安全一点。
           int mid = left + (right - left) / 2;
           if(target == nums[mid]){
               return true;
           } else if(target < nums[mid]){
               right = mid - 1;
           } else {
               left = mid + 1;
           }
       }
       return false;
    }
```

相关题目：

* [搜索插入位置](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/SearchInsertPosition.java)
* [x 的平方根](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/simple/Sqrtx.java)
* [搜索旋转排序数组](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/SearchInRotatedSortedArray.java)
* [在排序数组中查找元素的第一个和最后一个位置](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/FindFirstAndLastPositionOfElementInSortedArray.java)

### 递归回溯

递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。因此递归过程，最重要的就是查看能不能讲原本的问题分解为更小的**子问题**，这是使用递归的关键。

如果是**线型递归**，子问题直接回到父问题不需要回溯，但是如果是**树型递归**，父问题有很多分支，我需要从子问题回到父问题，进入另一个子问题。因此**回溯**是指在递归过程中，从某一分支的子问题回到父问题进入父问题的另一子问题分支，因为有时候进入第一个子问题的时候修改过一些变量，因此回溯的时候会要求改回父问题时的样子才能进入第二子问题分支。

相关题目：

* [括号生成](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/GenerateParentheses.java)
* [电话号码的字母组合](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/LetterCombinationsOfAPhoneNumber.java)

### KMP算法——字符串匹配问题

KMP 算法是一个快速查找匹配串的算法，它的作用就是：**快速在「原字符串」中找到「匹配字符串」。**

有这样两个字符串

A串：**abababaababacb**

B串：**ababacb**

如何找到B串在A串中的位置呢？

暴力思路：设置两个指针i，j分别指向A，B串的起始位置，从前往后逐个字符进行匹配，每次匹配失败后，i，j都需要回溯，从头匹配

![](http://rj5qpfcaf.hn-bkt.clouddn.com/algorithm/Snipaste_2022-10-24_20-05-28.png)

指针位置如图所示，`A[i]!=B[j]`，则i，j指针需要回溯，从头开始匹配

![](http://rj5qpfcaf.hn-bkt.clouddn.com/algorithm/Snipaste_2022-10-24_20-10-25.png)

i指针回头开始位置的下一位，j指针回到起始位置，相当于将B串右移了一位，依次类推直到匹配成功或者结束

这种做法的时间复杂度是O(m*n)。

如果要减少时间复杂度，我们就需要**充分利用匹配失败带给我们的有效信息**

**KMP算法核心：利用匹配失败后的信息尽量减少模式串与主串的匹配次数以达到快速匹配的目的（主串：A串，模式串：B串）**

首先了解字符串的前缀与后缀

对于B串：**ababacb**，前缀集合是**{a,ab,aba,abab,ababa,ababac}**，后缀集合是**{b,cb,acb,bacb,abacb,babacb}**

如何减少匹配次数呢？

如果我们人工的去移动指针，在上面这种不匹配的情况下我们会将i指针保持不变，指针j回到最有可能匹配成功的位置

**只回溯指针j，不回溯指针i**

![](http://rj5qpfcaf.hn-bkt.clouddn.com/algorithm/Snipaste_2022-10-24_20-44-19.png)

![](http://rj5qpfcaf.hn-bkt.clouddn.com/algorithm/Snipaste_2022-10-24_20-35-21.png)

因为`aba`在前面的就已经匹配过了，当且仅当A子串的后缀集合与B子串的前缀集合有交集时，将B串后移到指针i之前的这一段才能成功匹配

B串要移动多少位呢？或者说j指针要回溯到哪个位置？

我们要在已获得的信息中做到不遗漏的同时尽可能多的匹配，于是我们要找到A子串的后缀集合与B子串的前缀集合的交集里最长的那个元素，这个最长的元素才能使B串后移的最少且在已知信息中匹配的最多，这个最长元素的长度就是j指针回溯的位置，从那个位置往后和i指针之后的字符再开始匹配

同时我们可以发现A子串和B子串是相同的，因为它们都是经过匹配才留下来的，所以A子串的后缀集合与B子串的前缀集合的交集完全可以改为B子串的前缀集合与它本身的后缀集合的交集，j指针回溯的位置=B子串的最长公共前后缀

通过隐藏信息，匹配失败时A串与B串存在着一段相同的子串，j指针回溯的位置只与B串有关，与A串无关，所以我们可以在，A，B字符串匹配之前就通过B串计算出回溯位置，存在一个数组next里，next与B串形成映射数组，存的数据next[i]就是B[0]~B[i]的最长公共前后缀的长度

A，B字符串匹配的步骤（主串与模式串的匹配步骤）

* i，j初始化为0
* 如果A[i+1] == B[j+1]，i++，j++继续匹配
*  如果A[i+1] != B[j+1]，j指针回溯到next[j]（前提时j>0）,直到A[i+1] = B[j+1]，当j==0时且不满足A[i+1] == B[j+1]，忽略j,，i++直到A[i+1] == B[j+1]
* j==B串的长度时，说明找到了匹配位置

快速构建next数组

* B串自己与自己匹配，B[0]~B[i]的前缀与它的后缀匹配，后缀为主串，前缀为模式串，以递推的方式求出next数组，目的是求出B[0]~B[i]的最长公共前后缀的长度
* 如果匹配，next[i]=j+1，j是B串的前缀指针，也就是**当前字符匹配之前的最长公共前后缀的长度**，匹配成功了，所以要加1
* 如果不匹配，回溯j指针，j=next[j]，直到匹配成功

![](http://rj5qpfcaf.hn-bkt.clouddn.com/algorithm/Snipaste_2022-10-24_21-25-42.png)

代码示例

```java
    /**
     * KMP算法（原理和思路放在README.md，代码里实在说不明白）
     * @param haystack 主串
     * @param needle 模式串
     * @return 字符串中第一个匹配项的下标
     */
    public int strStr2(String haystack, String needle) {
        //模式串的自匹配，构建next数组
        int[] next = new int[needle.length()];//记录前缀与后缀的最长公共子串长度
        for (int i = 1,j = 0; i < needle.length() ; i++) {//用模式串来构建
            while (j>0&&needle.charAt(i)!=needle.charAt(j)){//不相同且j大于0，j指针回溯
                j = next[j-1];
            }
            if(needle.charAt(i)==needle.charAt(j)){//相同，i指针，j指针同时后移（i指针的移动在for循环里）
                j++;
            }
            next[i] = j;//存储前缀与后缀的最长公共子串长度（这个时候j已经在原有的基础上加1了，除非j=0）
        }
        //字符串匹配
        for (int i = 0,j=0; i < haystack.length(); i++) {
            while (j>0&&haystack.charAt(i)!=needle.charAt(j)){//j=0时，只考虑移动i指针直到haystack.charAt(i)==needle.charAt(j)
                j = next[j-1];//j指针回溯
            }
            if(haystack.charAt(i)==needle.charAt(j)){//单个字符匹配成功，i指针与j指针前移
                j++;
            }
            if(j==needle.length()){//返回第一个匹配项的下标
                return i-j+1;
            }
        }
        return -1;//没有匹配项返回-1
    }
```

相关题目：

* [找出字符串中第一个匹配项的下标](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/FindTheIndexOfTheFirstOccurrenceInAString.java)

### 倍增思想——使用加法来模拟整数乘法

在不使用乘法、除法和 mod 运算符的情况下，使用加法去计算**6*5**的积

最先想到的就是写一个循环“把 6 加 5 次”

```
0+6=6
6+6=12
12+6=18
18+6=24
24+6=30
```

那有没有更快的做法吗？

数字5表示的是多少个6进行相加，或者说是相加的次数，我们可以控制次数与数据同时进行倍增，再设置一个变量来记录结果

可以使用二进制数来帮助我们控制倍增

如5的二进制数为**1 0 1**，每次循环我们取末尾的值（循环结束前进行移位），为1表示前面的计算是有效的我们将记录结果的变量加上前面计算的结果，为0则不需要改变结果，它只表示位数递增；每次循环都需要将次数的值右移一位（相当于除以2），同时数值翻倍（相当于乘以2）

所以对于**6 * 5**有

```
设置记录结果的变量为 result，初始为0，次数为count，值为5，相加数据为num,值为6
5对应的二进制位为： 1 0 1

二进制第一位为1 
	result = result + num = 0 + 6 = 6
	num = num + num = 6 + 6 = 12
二进制第二位为0 
	result = result = 6
	num = num + num = 12 + 12 = 24
二进制第三位为1 
	result = result + num = 6 + 24 = 30
	num = num + num = 24 + 24 = 48
结束    
```

对于二进制位为0不需要改变result的值可能有些疑惑

举个例子：**10 * 8**

**8的二进制数为1 0 0 0，从右往左抵达1时，10已经进行了三次倍增 8相当于进行了反向三次倍增  ，即10+10，20+20，40+40（是在原有的基础上倍增，不是10+10+10）8/2，4/2，2/2，抵达1时，这个1代表前面的计算结果有效，需要进行记录，如果是0 0 0 0 再怎么叠加，结果都没有意义**

反过来说就是 1每次乘以2到8 与 10每次乘以2到80的次数是相同的，都需要三次

```java
long mul(long num, long count) {
        long result = 0;
        while (count > 0) {
            if ((count & 1) == 1) result += num;
            count >>= 1;
            num += num;
        }
        return result;
    }
```



相关题目：

* [两数相除](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/medium/DivideTwoIntegers.java)





