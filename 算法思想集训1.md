# 算法思想集训1

## 二分查找

### 算法介绍

对于有序数组，我们可以通过二分查找快速定位目标元素

```java
public int search(int key, int[] array) {
	int l = 0, h = array.length - 1;
	while (l <= h) {
		int mid = l + (h - l) / 2;
		if (key == array[mid]) return mid;
		if (key < array[mid]) h = mid - 1;
		else l = mid + 1;
	}
	return -1;
}
```

实现时需要注意以下细节： 

1. 在计算 mid 时不能使用 mid = (l + h) / 2 这种方式，因为 l + h 可能会导致加法溢出，应该使用 mid = l + (h - l) / 2。
2. 对 h 的赋值和循环条件有关，当循环条件为 l <= h 时，h = mid - 1；当循环条件为 l < h 时，h = mid。解释如下：在循环条件为 l <= h 时，如果 h = mid，会出现循环无法退出的情况，例如 l = 1，h = 1，此时 mid 也等于 1，如果此时继续执行 h = mid，那么就会无限循环；在循环条件为 l < h，如果 h = mid - 1，会错误跳过查找的数，例如对于数组 [1,2,3]，要查找 1，最开始 l = 0，h = 2，mid = 1，判断 key < arr[mid] 执行 h = mid - 1 = 0，此时循环退出，直接把查找的数跳过 了。
3.  l 的赋值一般都为 l = mid + 1。

同时二分查找可以存在一些变式，例如查找下标：第一个大于等于key的数与第一个小于等于key的数

**查找第一个大于等于key的下标（从左往右）**

```java
public int search(int key, int[] array) {
	int l = 0, h = array.length - 1;
	while (l <= h) {
		int mid = l + (h - l) / 2;
		if (array[mid] < key) l = mid + 1;
		else r = mid - 1;
	}
	return l;
}
```

结果需要返回左指针对应的下标，左指针总是慢慢接近目标值，右指针在最后会左移一位用来打破循环

**查找第一个小于等于key的下标（从右往左）**

```java
public int search(int key, int[] array) {
	int l = 0, h = array.length - 1;
	while (l <= h) {
		int mid = l + (h - l) / 2;
		if (array[mid] > key) r = mid - 1;
		else l = mid + 1;
	}
	return r;
}
```

结果需要返回右指针对应的下标，右指针总是慢慢接近目标值，左指针在最后会右移一位用来打破循环

### 练习

#### x 的平方根

##### 题目描述

[原题链接](https://leetcode.cn/problems/sqrtx/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/binary_search/Sqrtx.java)

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

 

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

 

**提示：**

- `0 <= x <= 231 - 1`

##### 题解

根据题意，返回类型是整数，结果只保留 **整数部分**，如数字8，返回结果 2 而非 3，2^2=4，3^3=9。可以看作是在给定`[1,x]`范围内，查找第一个平方小于等于x的数，1到8中，从右往左2是第一个平方小于等于8的数。为了避免越界，用`x / mid`来替代`mid * mid`与mid比较

```java
    public int mySqrt(int x) {
        if (x < 1) return x;
        int left = 1, right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int num = x / mid;
            if (mid > num) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return right;
    }
```

#### 排列硬币

##### 题目描述

[原题链接](https://leetcode.cn/problems/arranging-coins/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/binary_search/ArrangingCoins.java)

你总共有 `n` 枚硬币，并计划将它们按阶梯状排列。对于一个由 `k` 行组成的阶梯，其第 `i` 行必须正好有 `i` 枚硬币。阶梯的最后一行 **可能** 是不完整的。

给你一个数字 `n` ，计算并返回可形成 **完整阶梯行** 的总行数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg)

```
输入：n = 5
输出：2
解释：因为第三行不完整，所以返回 2 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg)

```
输入：n = 8
输出：3
解释：因为第四行不完整，所以返回 3 。
```

 

**提示：**

- `1 <= n <= 231 - 1`

##### 题解

根据题意需要返回可形成 **完整阶梯行** 的总行数，8枚硬币只有3行完整返回3，前三行和为 `3*(1+3)/2=6`，前四行和为`4*(1+4)/2=10`。所以看作在给定范围`[1,n]`中，寻找第一个x，使得前x行的和小于等于n。为了避免越界前x行和用`long`型来表示

```java
    public int arrangeCoins(int n) {
        int left = 1, right = n;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            long num = mid * (1L + mid) / 2;
            if (num > n) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return right;
    }
```

####  有序数组中的单一元素

##### 题目描述

[原题链接](https://leetcode.cn/problems/single-element-in-a-sorted-array/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/binary_search/SingleElementInASortedArray.java)

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

 

**示例 1:**

```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

**示例 2:**

```
输入: nums =  [3,3,7,7,10,11,11]
输出: 10
```

 



**提示:**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 105`

##### 题解

设计的解决方案必须满足 `O(log n)` 时间复杂度，所以不能用位运算，考虑二分查找。对于数组`[3,3,7,7,10,11,11]`，发现在10之前，偶数位为相同元素的第一个（0号位的3，2号位的7）；10之后奇数位为相同元素的第一个。利用这一特点进行二分查找。

```java

    public int singleNonDuplicate(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (mid % 2 == 1) mid--;//调整到偶数位
            if (nums[mid] == nums[mid + 1]) left = mid + 2;//说明mid在目标元素左边
            else right = mid;//mid在目标元素右边，同时mid可能就是目标元素，所以right=mid
        }
        return nums[left];//最终left和right都指向目标元素
    }
```

## 贪心思想

### 算法介绍

贪心思想保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。

### 练习

####  分发饼干

##### 题目描述

[原题链接](https://leetcode.cn/problems/assign-cookies/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/greedy_thinking/AssignCookies.java)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

 

**提示：**

- `1 <= g.length <= 3 * 10^4`
- `0 <= s.length <= 3 * 10^4`
- `1 <= g[i], s[j] <= 2^31 - 1`

##### 题解

先满足饭量小的小孩，并且尽量做到刚好满足，让大饼干去满足饭量更大的小孩

```java
    public int findContentChildren(int[] g, int[] s) {
        //排序
        Arrays.sort(g);
        Arrays.sort(s);
        int i=0,j=0;
        while (i<g.length&&j<s.length){
            if(s[j]>=g[i]) i++;//满足，下一个小孩
            j++;//换饼干（饼干可能被吃了也有可能太小了选择跳过）
        }
        return i;
    }
```

#### 用最少数量的箭引爆气球

##### 题目描述

[原题链接](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/greedy_thinking/MinimumNumberOfArrowsToBurstBalloons.java)

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

 

**示例 1：**

```
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
```

**示例 2：**

```
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。
```

**示例 3：**

```
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。
```

 



**提示:**

- `1 <= points.length <= 10^5`
- `points[i].length == 2`
- `-2^31 <= xstart < xend <= 2^31 - 1`

##### 题解

先根据右区间对数组进行排序，从左往右投飞镖，并且在每次投飞镖时满足以下条件：

1. 左边已经没有气球了； 
2. 本次投飞镖能够刺破最多的气球。

对于排序后的数组，`[[1,6],[2,8],[7,12],[10,16]]`，可以发现`[1,6],[2,8]`存在公共公共区域，`[7,12],[10,16]`存在公共区域。数组是根据右边界进行排序的，当第二个数组的左边界小于等于第一个数组的右边界，则两数组一定存在公共区域。当判断多个数组如`[1,6],[2,8],[7,12]`是否有公共区域是，只需判断最后一个数组的左边界是否小于等于第一个数组的右边界，满足条件则存在公共区域。

```java
    public int findMinArrowShots(int[][] points) {
        if(points.length==0) return 0;
        Arrays.sort(points, Comparator.comparingInt(a -> a[1]));//根据右边界排序
        int boundary = points[0][1];//设置临界点，第一个数组的右边界
        int count = 1;//第一个飞镖
        for (int i = 1; i < points.length ; i++) {
            if(points[i][0]<=boundary) continue;//存在公共区域，同一个飞镖就可以打破气球
            //不存在公共区域
            boundary = points[i][1];//更新第一个数组右边界
            count++;//换一个飞镖
        }
        return count;
    }
```

#### 买卖股票的最佳时机 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/greedy_thinking/BestTimeToBuyAndSellStockII.java)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

 

**提示：**

- `1 <= prices.length <= 3 * 10^4`
- `0 <= prices[i] <= 10^4`

##### 题解

对于数组`[7,1,5,3,6,4]`，求最大利润只需找出所有差值即可，`1,5`，`3,6`差值和为7，即为最大利润。对于` [a, b, c, d]`，如果有 `a <= b <= c <= d `，那么最大收益为 `d - a`。而 `d - a = (d - c) + (c - b) + (b - a) `，因此当访问到一个 prices[i] 且` prices[i+1] - prices[i] > 0`，那么就把 `prices[i+1] - prices[i]` 添加加到收益中，从而在局部最优的情况下也保证全局最优。

```java
    public int maxProfit(int[] prices) {
        int profit = 0;//利润
        for (int i = 0; i < prices.length-1; i++) {
            if(prices[i]<prices[i+1]) profit+=prices[i+1]-prices[i];//收益和
        }
        return profit;
    }
```

#### 种花问题

##### 题目描述

[原题链接](https://leetcode.cn/problems/can-place-flowers/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/greedy_thinking/CanPlaceFlowers.java)

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false`。

 

**示例 1：**

```
输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
```

**示例 2：**

```
输入：flowerbed = [1,0,0,0,1], n = 2
输出：false
```

 

**提示：**

- `1 <= flowerbed.length <= 2 * 104`
- `flowerbed[i]` 为 `0` 或 `1`
- `flowerbed` 中不存在相邻的两朵花
- `0 <= n <= flowerbed.length`

##### 题解

从左往右找到合适的位置插上花，在局部最优的情况下去保证全局最优。插画的地方必须是空地且前后相邻位置没有花

```java
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        for (int i = 0; i < flowerbed.length; i++) {
            //判断插花条件是否满足
            if(flowerbed[i] == 0 && ((i == 0 || flowerbed[i - 1] == 0)&&(i==flowerbed.length-1||flowerbed[i+1]==0))) {
                flowerbed[i] = 1;//插花
                n--;//花的数量减1
            }
        }
        return n<=0;//判断花是否插完
    }
```

#### 非递减数列

##### 题目描述

[原题链接](https://leetcode.cn/problems/non-decreasing-array/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/greedy_thinking/NonDecreasingArray.java)

给你一个长度为 `n` 的整数数组 `nums` ，请你判断在 **最多** 改变 `1` 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中任意的 `i` `(0 <= i <= n-2)`，总满足 `nums[i] <= nums[i + 1]`。

 

**示例 1:**

```
输入: nums = [4,2,3]
输出: true
解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。
```

**示例 2:**

```
输入: nums = [4,2,1]
输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 104`
- `-105 <= nums[i] <= 105`

##### 题解

问题的关键在于出现`nums[i]>nums[i+1]`是修改谁的值并且只用考虑两种修改方式`nums[i]=nums[i+1]`与`nums[i+1]>nums[i]`。

对于数组`[5,7,1,8]`，7>1，这是我们需要修改1为7即`nums[i+1]>nums[i]`，一旦修改7为1则之前的条件也不满足（5>1）

对于数组`[4,2,3]`，只需要修改4为2即可，修改2为4只会让后面的数值变大，即`nums[i+1]=nums[i]`存在让后面数组的数据变大导致后续数据不满足条件

所以应优先考虑令 `nums[i] = nums[i+1]`，因为如果修改 `nums[i+1] = nums[i]` 的话，那么 `nums[i+1]` 这个数会变大，那么就有可能比 `nums[i + 2]` 大，从而影响了 后续操作。还有一个比较特别的情况就是 `nums[i+1] < nums[i-1]`，只修改 `nums[i] = nums[i+1] `不能令数组成为非递减，只能通过修改 `nums[i+1] = nums[i]` 才行。

```java
    public boolean checkPossibility(int[] nums) {
        int count = 1;
        for (int i = 0; i < nums.length-1; i++) {
            if(nums[i]>nums[i+1]){
                count--;
                if(i>0&&nums[i+1]<nums[i-1]){
                    nums[i+1]=nums[i];
                } else {
                    nums[i] = nums[i+1];
                }
            }

        }
        return count>=0;
    }
```

#### 判断子序列

##### 题目描述

[原题链接](https://leetcode.cn/problems/is-subsequence/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/greedy_thinking/IsSubsequence.java)

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**进阶：**

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**示例 2：**

```
输入：s = "axc", t = "ahbgdc"
输出：false
```

 

**提示：**

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- 两个字符串都只由小写字符组成。

##### 题解

只需要判断s中的字符在t中第一次出现的位置，后面的字符在这个位置的基础上去寻找其对应的第一个位置

```java
    public boolean isSubsequence(String s, String t) {
        int i = 0,j=0;
        while (i<s.length()){
            j = t.indexOf(s.charAt(i),j);//在前一个字符出现的位置往后找
            if(j==-1) return false;//找不到，则不是子序列
            i++;
            j++;
        }
        return true;
    }
```

#### 划分字母区间

##### 题目描述

[原题链接](https://leetcode.cn/problems/partition-labels/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/greedy_thinking/PartitionLabels.java)

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

 

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

**示例 2：**

```
输入：s = "eccbbbbdec"
输出：[10]
```

 

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

##### 题解

从左往右找到第一个字符最后出现的位置，并在这个范围内去寻找其它字符最后出现的位置，范围需要动态更新，始终以最大的位置的坐标为右边界

```java
    public List<Integer> partitionLabels(String s) {
        List<Integer> list = new ArrayList<>();
        int i = 0;
        while (i<s.length()){
            int j = s.lastIndexOf(s.charAt(i));//开始字符最后出现的位置
            for (int k = i+1; k < j; k++) {
                j = Math.max(j,s.lastIndexOf(s.charAt(k)));//选取更大的右边界
            }
            list.add(j-i+1);
            i = j+1;
        }
        return list;
    }
```

我们可以将字符最后出现的位置提前记录，避免重复搜索

```java
    public List<Integer> partitionLabels2(String s) {
        List<Integer> list = new ArrayList<>();
        int[] last = new int[26];
        for (int i = 0; i < 26 ; i++) {//提前记录
            last[i] = s.lastIndexOf((char)(i+'a'));
        }
        int i=0;
        while (i<s.length()){
            int j = last[s.charAt(i)-'a'];
            for (int k = i+1; k < j; k++) {
                j = Math.max(j,last[s.charAt(k)-'a']);
            }
            list.add(j-i+1);
            i = j+1;
        }
        return list;
    }
```

#### 根据身高重建队列

##### 题目描述

[原题链接](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/greedy_thinking/QueueReconstructionByHeight.java)

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

 



**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

**示例 2：**

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

 

**提示：**

- `1 <= people.length <= 2000`
- `0 <= hi <= 10^6`
- `0 <= ki < people.length`
- 题目数据确保队列可以被重建

##### 题解

矮个子排在哪都对高个子没有影响，但是高个子排在矮个子前面就会造成影响。可以根据身高进行降序排序，身高相同按照k升序。将身高高的人先按照k进行插入，因为矮个子排在哪都对高个子没有影响

```java
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                if(a[0]==b[0]) return a[1]-b[1];
                return b[0]-a[0];
            }
        });
        List<int[]> list = new ArrayList<>();
        for (int[] person : people) {
            list.add(person[1], new int[]{person[0], person[1]});
        }
        for (int i = 0; i <people.length ; i++) {
            people[i][0] = list.get(i)[0];
            people[i][1] = list.get(i)[1];
        }
        return people;
        
    }
```

## 双指针

### 算法介绍

双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。

### 练习

#### 两数之和 II - 输入有序数组

##### 题目描述

[原题链接](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/double_pointer/TwoSumIIInputArrayIsSorted.java)

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

 

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

 

**提示：**

- `2 <= numbers.length <= 3 * 104`
- `-1000 <= numbers[i] <= 1000`
- `numbers` 按 **非递减顺序** 排列
- `-1000 <= target <= 1000`
- **仅存在一个有效答案**

##### 题解

数组 按 **非递减顺序** 排列，可以定义两个指针，left 指向数组首部，right 指向数组尾部，通过向右移动 left 来使和增大，向左移动 right 让和减小。

如果两个指针指向元素的和 sum == target，那么得到要求的结果；如果 sum > target，移动右指针，使 sum 变小一些；如果 sum < target，移动左指针，使 sum 变大一些。

```java
    public int[] twoSum(int[] numbers, int target) {
        int left = 0,right = numbers.length-1;
        while (left<right){
            int sum = numbers[left]+numbers[right];
            if(sum==target){
                return new int[]{left+1,right+1};
            } else if(sum<target){
                left++;
            } else {
                right--;
            }
        }
        return new int[]{};
    }
```

#### 反转字符串中的元音字母

##### 题目描述

[原题链接](https://leetcode.cn/problems/reverse-vowels-of-a-string/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/double_pointer/ReverseVowelsOfAString.java)

给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现不止一次。

 

**示例 1：**

```
输入：s = "hello"
输出："holle"
```

**示例 2：**

```
输入：s = "leetcode"
输出："leotcede"
```

 

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由 **可打印的 ASCII** 字符组成

##### 题解

使用两个指针，一头一尾，如果两个指针同时指向元音字母，则反转（交换），否则通过移动指针来使两个指针同时指向元音字母

```java
    public String reverseVowels(String s) {
        char[] array = s.toCharArray();
        int left = 0,right = s.length()-1;
        while (left<right){
            if(check(array[left])&&check(array[right])){
                char temp = array[left];
                array[left] = array[right];
                array[right] = temp;
                left++;
                right--;
            } else if(check(array[left])){
                right--;
            } else {
                left++;
            }
        }
        return new String(array);
    }

    public boolean check(char c){
        return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'|| c=='A'||c=='E'||c=='I'||c=='O'||c=='U';
    }
```

#### 平方数之和

##### 题目描述

[原题链接](https://leetcode.cn/problems/sum-of-square-numbers/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/double_pointer/SumOfSquareNumbers.java)

给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a^2 + b^2 = c` 。

 

**示例 1：**

```
输入：c = 5
输出：true
解释：1 * 1 + 2 * 2 = 5
```

**示例 2：**

```
输入：c = 3
输出：false
```

 

**提示：**

- `0 <= c <= 231 - 1`

##### 题解

使用双指针，一个指向数字0，一个指向`(int) Math.sqrt(c)`，通过移动指针尝试去寻找符合要求的数字，判断`a^2 + b^2`与c的关系，可以转换成判断`a^2`与`c-b^2`的关系来避免数值越界

```java
    public boolean judgeSquareSum(int c) {
        int left = 0, right = (int) Math.sqrt(c);
        while (left <= right) {
            int target = c - left * left;//使用减法来代替加法，避免越界
            if (target == right * right) {
                return true;
            } else if (target < right * right) {
                right--;
            } else {
                left++;
            }
        }
        return false;
    }
```

#### 验证回文串 II

##### 题目描述

[原题链接](https://leetcode.cn/problems/valid-palindrome-ii/description/)

[测试代码](https://github.com/dar02kon/LeetCode/blob/master/src/com/dar/leetcode/algorithm_training/double_pointer/ValidPalindromeII.java)

给你一个字符串 `s`，**最多** 可以从中删除一个字符。

请你判断 `s` 是否能成为回文字符串：如果能，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：s = "aba"
输出：true
```

**示例 2：**

```
输入：s = "abca"
输出：true
解释：你可以删除字符 'c' 。
```

**示例 3：**

```
输入：s = "abc"
输出：false
```

 

**提示：**

- `1 <= s.length <= 105`
- `s` 由小写英文字母组成

##### 题解

从两边往中间靠，遇见不相同的需要考虑移动左指针和右指针两种情况

```java
    public boolean validPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left <= right) {
            if (s.charAt(left) == s.charAt(right)) {
                left++;
                right--;
                continue;
            }
            return check(s, left + 1, right) || check(s, left, right - 1);
        }
        return true;
    }

    public boolean check(String s, int left, int right) {
        while (left <= right) {
            if (s.charAt(left) == s.charAt(right)) {
                left++;
                right--;
                continue;
            }
            return false;
        }
        return true;
    }
```

